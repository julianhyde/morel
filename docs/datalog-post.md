<!--
{% comment %}
Licensed to Julian Hyde under one or more contributor license
agreements.  See the NOTICE file distributed with this work
for additional information regarding copyright ownership.
Julian Hyde licenses this file to you under the Apache
License, Version 2.0 (the "License"); you may not use this
file except in compliance with the License.  You may obtain a
copy of the License at

http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing,
software distributed under the License is distributed on an
"AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
either express or implied.  See the License for the specific
language governing permissions and limitations under the
License.
{% endcomment %}
-->

# Datalog on Morel

A recent commit adds support for Datalog to the Java implementation of
Morel.  You can now parse, validate and execute programs in Datalog.

```sml
Datalog.execute ".decl edge(x:int, y:int)
.decl path(x:int, y:int)
edge(1,2).
edge(2,3).
path(X,Y) :- edge(X,Y).
path(X,Z) :- path(X,Y), edge(Y,Z).
.output path";
> val it = {path=[{x=1,y=2},{x=2,y=3},{x=1,y=3}]}
>   : {path:{x:int, y:int} bag} variant
```

(The dialect is based on Souffle, including directives like `.decl`
and `.output`, but we changed the `symbol` and `number` types to
`string` and `int`, to be consistent with Morel's type system.)

## Library functions

You'll notice that the Datalog program is an argument to a library
function called `Datalog.execute`. The implementation is real (we go
into details below) but packaging it as library functions let us use
Morel's shell, scripting and testing framework.

We add three functions in the `Datalog` structure:

| Name        | Type                | Description |
|-------------|---------------------|-------------|
| `execute`   | `string -> variant` | Executes a Datalog program. Returns the result as a `variant`. |
| `translate` | `string -> string`  | Translates a Datalog program to an equivalent Morel program. |
| `validate`  | `string -> string`  | Parses and validates a Datalog program. Returns either a type or an error. |

To implement the `execute` function, we had a problem to solve. The
type of the Datalog is not known until run time, but the function must
have a fixed type. The solution was to add `variant`, a built-in data
type that is a union of all primitive and composite types:

```sml
datatype variant =
    UNIT
  | BOOL of bool
  | INT of int
  | REAL of real
  | CHAR of char
  | STRING of string
  | LIST of variant list
  | BAG of variant list
  | VECTOR of variant list
  | VARIANT_NONE
  | VARIANT_SOME of variant
  | RECORD of (string * variant) list
  | CONSTANT of string
  | CONSTRUCT of string * variant
```

The implementation of `variant` is a thin wrapper that contains a type
and a native value, so even large values can be returned without
copying.

Subsequent examples will show the Datalog program without its function
wrappers, and the result stripped of its `variant` wrapper.

## Translation

How did we implement Datalog support? Underneath the library
functions, translation has a fairly obvious structure. Three steps are
executed in succession:
1. The parser (generated by Claude) converts a Datalog string to a
   parse tree.
2. The validator (also generated by Claude) makes sure that the
   program is valid (that rules are safe, grounded and stratified)
   and deduces its type.
3. The translator generates a Morel program that is equivalent to
   the Datalog program.
4. The Morel program is evaluated.

The tricky part is step 3. Here is a Datalog program and its
equivalent Morel program.

Datalog:
```
.decl edge(x:int, y:int)
.decl path(x:int, y:int)
edge(1,2).
edge(2,3).
path(X,Y) :- edge(X,Y).
path(X,Z) :- path(X,Y), edge(Y,Z).
.output path
```

Morel:
```sml
let
  val edge_facts = [(1, 2), (2, 3)]
  fun edge (x, y) = (x, y) elem edge_facts
  fun path (x, y) =
    edge (x, y) orelse
    (exists v0 where path (x, v0) andalso edge (v0, y))
in
  {path = from x, y where path (x, y)}
end
```

You'll notice that the two programs have the same structure.  Datalog
rules without a body (such as `edge(1,2)` and `edge(2,3)`) are
gathered into a list of tuples (`edge_facts`).

Each rule becomes a boolean function.  If there are several
comma-separated predicates in a rule's body, they are combined using
`andalso`.  If there are several rules of the same name, their
conditions are combined using `orelse`.  Invocations of a rule become
function calls, which, like rules, may be recursive.

The body of the rule `path(X,Z) :- path(X,Y), edge(Y,Z)` has a
variable, `Y`, that does not occur in the head. It is translated to
`exists v0`.

A Datalog program may have several `.output` directives.  The Morel
program returns a single value, a record with one field for each
directive.

## Predicate inversion

The magic lies deeper.

At heart of the generated Morel program is a query: `from x, y where
path (x, y)`.  It differs from a regular query in that the variables
`x` and `y` are unbounded.  (In a conventional query, every variable
is bounded, meaning it iterates over a collection, for example, `from
x in someTable, y in someOtherTable`.)

## What's so great about Datalog?

What's so great about Datalog, anyway?

Datalog is the latest in the line of approaches to queries and logic.
In the beginning, like Cain and Abel, there were intensional and
extensional set theory. You could define a set by its properties (the
set of all cars that are red) or by performing operations on existing
sets (intersect the set of all cars with the set of all red objects).

When E.F. Codd founded relational database theory, he proved that
relational algebra and relational calculus are equivalent.

SQL is (largely) based on relational algebra, and Datalog is largely
based on relational calculus.

If the languages are equivalent, why does it matter? First, we would
like to embed queries in other programs, functional programming is the
predominant paradigm for general-purpose programs, and relational
algebra is a form of functional programming.

Second, some kinds of query are easier to express in one paradigm than
the other. Queries that iterate until they reach a fixed point are
easier to express in the calculus (Datalog).  In the algebra, a query
reaches a fixed point when a value stops 'growing'.  For simple
fixed-point queries such as computing transitive closure, that value
is a set, combined using union. But for more complex fixed-point
queries the programmer needs to define a data type with the properties
of a partially-ordered set. In the calculus, the data type is boolean.

## Conclusion

The Datalog implementation demonstrates that Morel is a very powerful
language.

We make no promises about the efficiency of the implementation.  Now
we can translate programs with unbounded variables into relational
algebra with iteration, we can use conventional techniques to optimize
that algebra.
