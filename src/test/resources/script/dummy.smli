(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *)

let
  val records = from r in bag [1,2]
in
  from r2 in records
end;
> val it = [{i=1,j=2}] : {i:int,j:int} bag

(* TODO
let
  val evenEmp =
    from e in scott.emp
in
  from e in evenEmp
end;
*)
(* TODO
let
  val evenEmp =
    from e in scott.emp
in
  from e in evenEmp
end;
*)
(* TODO
let
  fun evenEmp x =
    from e in scott.emp
    where e.empno mod 2 = 0
in
  from e in (evenEmp 1)
  where e.deptno = 10
  yield e.ename
end;
*)

1 elem [0,1,2];
> val it = true : bool
1 elem (bag [0,1,2]);
> val it = true : bool

(* WORKS
*)
from {i, j} in [{i=1,j=2}];
> val it = [{i=1,j=2}] : {i:int, j:int} list
from (i, j) in [{i=1,j=2}];
> 0.0-0.0 Error: Cannot deduce type: no valid overloads
>   raised at: 0.0-0.0

from (i, j) in [(1,2)];
> val it = [{i=1,j=2}] : {i:int, j:int} list


from i in [1,2,1,3] group i compute count;
> val it = [{count=2,i=1},{count=1,i=2},{count=1,i=3}] : {count:int, i:int} list

(*) empty 'from' is ordered
from;
> val it = [()] : unit list

(* A type similar to the built-in 'bag', and a function to convert any list to
   a multiset. *)
datatype 'a multiset =
    MULTI_NIL
  | MULTI_CONS of ('a * 'a multiset);
> datatype 'a multiset = MULTI_CONS of 'a * 'a multiset | MULTI_NIL
fun listToMultiset [] = MULTI_NIL
  | listToMultiset (h :: t) = MULTI_CONS (h, listToMultiset t);
> val listToMultiset = fn : 'a list -> 'a multiset

(* Declare that 'unsort' is overloaded. *)
over unsort;
> over unsort

val inst unsort = fn SOME x => [x] | NONE => [];
> val unsort = fn : 'a option -> 'a list
unsort (SOME 1);
> val it = [1] : int list

(* Declare an instance of 'unsort' that converts a list to a multiset. *)
val inst unsort = fn aList => listToMultiset aList;
> val unsort = fn : 'a list -> 'a multiset
unsort [1, 2];
> val it = MULTI_CONS (1,MULTI_CONS (2,MULTI_NIL)) : int multiset

(* Clear the environment. The number of variables in the environment
 * can cause subtle differences in behavior, so we eliminate that
 * source of variability. *)
Sys.clearEnv ();
> val it = () : unit

over o4a;
> over o4a
val inst o4a = fn NONE => [] | SOME x => [x];
> val o4a = fn : 'a option -> 'a list
val inst o4a = fn list => List.null list;
> val o4a = fn : 'a list -> bool
(* TODO
o4a;
> val it = fn : 'a list -> bool
*)
o4a (SOME 1);
> val it = [1] : int list
o4a ["a"];
> val it = false : bool

(* DONE
bag [1,2,3];
> val it = [1,2,3] : int bag
from e in [1,2,3];
> val it = [1,2,3] : int list
fun l2 [] = 0 | l2 (h :: (t: bool list)) = 1 + (l2 t);
> val l2 = fn : bool list -> int
bag [1,2,3];
> val it = [1,2,3] : int bag
bag [[1],[2],[3]];
> val it = [[1],[2],[3]] : int list bag
from e in (bag [1,2,3]);
> val it = [1,2,3] : int bag
from i in (bag [1,2,3]) where i > 1;
> val it = [2,3] : int bag
from i in (bag [1,2,3]) distinct;
> val it = [1,2,3] : int bag
from i in [1,2,3] distinct;
> val it = [1,2,3] : int bag
from i in (bag [1,2,3]) group;
> val it = [()] : unit bag
from i in (bag [1,2,3]) group i;
> val it = [1,2,3] : int bag
fun g [] = NONE
  | g (h :: t) = SOME (h, t);
> val g = fn : 'a list -> ('a * 'a list) option

fun chars s =
    List.tabulate (size s, fn i => (i, String.sub (s, i)));
> val chars = fn : string -> (int * char) list
fun symPos c (s, i) =
    from (i2, c2) in chars s
      where i2 = i andalso c2 = c
      yield i + 1;
> val symPos = fn : char -> string * int -> int list
fun seqPos r1 r2 (s, i) =
    from j in r1 (s, i),
        k in r2 (s, j)
      yield k;
> val seqPos = fn
>   : ('a * 'b -> 'c list) -> ('a * 'c -> 'd list) -> 'a * 'b -> 'd list
val r = seqPos (symPos #"l") (symPos #"o");
> val r = fn : string * int -> int list

*)

(*) CURRENT
from (i, j) in [(14, 3), (~14, 3), (14, ~3), (~14, ~3)]
 where (i div j) <> Int.`div` (i, j)
 orelse (i mod j) <> Int.`mod` (i, j);
> val it = [] : {i:int, j:int} list

bag [1,2];
> val it = [1,2] : int bag
from i in bag [1,2];
> val it = [1,2] : int bag

(* TODO
List.length Bag.nil;
> val it = 0 : int
from i in (bag [1,2,3]) group i compute count;
> val it = [1,2,3] : int bag
(*) Allow applying bag function (op elem: ('a * 'bag) -> bool) to list
from i in [1,2]
where i elem [2,3];

from i in [1,2,3]
group i compute x = (fn a => a);
> val it = [{i=1,x=[1]},{i=2,x=[2]},{i=3,x=[3]}] : {i:int, x:int bag} bag

2 elem [2,3];
*)

(*) End dummy.smli
