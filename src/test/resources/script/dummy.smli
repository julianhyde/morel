(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *)
SOME (1,[2,3]);
> val it = SOME (1,[2,3]) : (int * int list) option
datatype 'x tree = Empty | Node of 'x tree * 'x * 'x tree;
> datatype 'a tree = Empty | Node of 'a tree * 'a * 'a tree
datatype foo = W | X | Y of int;
> datatype foo = W | X | Y of int
X;
> val it = X : foo
Y;
> val it = fn : int -> foo
SOME (SOME true);
> val it = SOME (SOME true) : bool option option
fun wordCount lines =
  let
    fun split0 [] word words = word :: words
      | split0 (#" " :: s) word words = split0 s "" (word :: words)
      | split0 (c :: s) word words = split0 s (word ^ (String.str c)) words
    fun split s = List.rev (split0 (String.explode s) "" [])
  in
    from line in lines,
        word in split line
    group word compute count
  end;
> val wordCount = fn : string list -> {count:int, word:string} list
(*) End dummy.smli
