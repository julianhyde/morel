(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *)

over toList;
> over toList
val inst toList = fn bag => if Bag.length bag < 0 then "" else "bag";
> val toList = fn : 'a bag -> string
val inst toList = fn list => if List.length list < 0 then "" else "list";
> val toList = fn : 'a list -> string

(*
from i in [1, 2, 3]
  compute toList over i;
> val it = "list" : string
*)
from i in bag [1, 2, 3]
  compute toList over i;
> val it = "bag" : string

(*) List agg applied to list
from i in [1, 2, 3]
  compute List.hd over i;
> val it = 1 : int

(*) List agg applied to bag
from i in bag [1, 2, 3]
  compute List.hd over i;
> val it = 1 : int

(*) Bag agg applied to list
from i in [1, 2, 3]
  compute Bag.hd over i;
> val it = 1 : int

(*) Bag agg applied to bag
from i in bag [1, 2, 3]
  compute Bag.hd over i;
> val it = 1 : int

let
  fun listAgg list = List.hd list
in
  from i in bag [1, 2]
    compute listAgg over i
end;
> val it = 1 : int

fun listAgg list = List.hd list;
> val listAgg = fn : 'a list -> 'a
fun bagAgg bag = Bag.hd (Bag.tl bag);
> val bagAgg = fn : 'a bag -> 'a

(*) List agg over list input (should return first element)
from i in [1, 2]
  compute listAgg over i;
> val it = 1 : int

(*) Bag agg over bag input (should return second element)
from i in bag [1, 2]
  compute bagAgg over i;
> val it = 2 : int

(*) List agg over bag input (should return first element)
from i in bag [1, 2]
  compute listAgg over i;
> val it = 1 : int

(*) Fails from this point on

over overAgg;
> over overAgg
val inst overAgg = fn list => if List.length list < 0 then "" else "list";
> val overAgg = fn : 'a list -> string
val inst overAgg = fn bag => if Bag.length bag < 0 then "" else "bag";
> val overAgg = fn : 'a bag -> string

overAgg [1,2,3];
> val it = "list" : string
overAgg (bag [1,2,3]);
> val it = "bag" : string

(*) Overloaded agg applied to list
from i in [1, 2, 3]
  compute overAgg over i;
> val it = "list" : string

(*) Overloaded agg applied to bag
from i in bag [1, 2, 3]
  compute overAgg over i;
> val it = "bag" : string

(*) Polymorphic agg applied to list
from i in [1, 2, 3]
  compute Fn.id over i;
> val it = [1,2,3] : int list

(*) Polymorphic agg applied to bag
from i in bag [1, 2, 3]
  compute Fn.id over i;
> val it = [1,2,3] : int bag

(* Crashes
from (k, v) in [(1, 5), (1, 6), (2, 7), (2, 10)]
  group k compute {x = (fn vs => k + sum vs) over v};
> val it = [{k=1,x=12},{k=2,x=19}] : {k:int, x:int} list
*)

from i in [1, 2, 3]
  compute (fn x => x) over i;
> val it = [1,2,3] : int list

from i in [1, 2, 3]
  compute (fn x => x) over i;
> val it = [1,2,3] : int list

from i in bag [1, 2]
  compute sum over i;
> val it = 3 : int

from i in [1, 2]
  compute sum over i;
> val it = 3 : int

from e in [{a = 1, b = 5}, {a = 0, b = 1}, {a = 1, b = 1}]
  group e.a compute {rows = (fn x => x) over e};
> val it = [{a=1,rows=[{a=1,b=5},{a=1,b=1}]},{a=0,rows=[{a=0,b=1}]}]
>   : {a:int, rows:{a:int, b:int} list} list

(*) Aggregate function that is a closure that references group key
from (k, v) in [(1, 5), (1, 6), (2, 7), (2, 10)]
  group k compute {x = (fn vs => k + sum vs) over v};
> val it = [{k=1,x=12},{k=2,x=19}] : {k:int, x:int} list

from (k, v) in [(1, 5), (1, 6), (2, 7), (2, 10)]
  group {k2 = k} compute {x = (fn vs => k2 + sum vs) over v};
> val it = [{k2=1,x=12},{k2=2,x=19}] : {k2:int, x:int} list

val recList = [{i=1,b=true}, {i=2,b=false}, {i=1,b=false}];
> val recList = [{b=true,i=1},{b=false,i=2},{b=false,i=1}] : {b:bool, i:int} list
val recBag = bag recList;
> val recBag = [{b=true,i=1},{b=false,i=2},{b=false,i=1}] : {b:bool, i:int} bag

from r in recBag group r.i compute {bs = (fn x => x) over r.b} order DESC i;
> val it = [{bs=[false],i=2},{bs=[true,false],i=1}] : {bs:bool bag, i:int} list

(*) End dummy.smli
