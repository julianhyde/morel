(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *)
(*
"this is a simple script; modify it for debugging test cases";
> val it = "this is a simple script; modify it for debugging test cases" : string
*)

(*) Succeeds
(*
let
  val foo = List.tl
in
  from i in bag ["a", "b", "c"]
    compute foo over i
end;
> val it = ["b","c"] : string list
*)

(*) Succeeds
(*
from i in bag ["a", "b"]
  compute List.hd over i;
> val it = "a" : string
*)

(*) Fails
let
  val listAgg = List.hd
in
  from i in bag ["a", "b"]
    compute listAgg over i
end;
> val it = "a" : string

(*) union followed by group
from x in (from e in [1,2])
    union (from d in [2,3])
group x compute {c = count over ()}
order (c, x);
> val it = [{c=1,x=1},{c=1,x=3},{c=2,x=2}] : {c:int, x:int} list

(*) A variable via which we can access relations.
val s = file.data.scott;
> val s =
>   {bonuses=<relation>,depts=<relation>,emps=<relation>,salgrades=<relation>}
>   : {bonuses:{...} list, depts:{...} list, emps:{...} list,
>      salgrades:{...} list, ...}

(*) Access two relations (emps, depts) simultaneously via a variable (s).
from d in s.depts
  join e in s.emps on d.deptno = e.deptno
  group e.deptno compute count over ()
  order deptno;
> val it = [{count=3,deptno=10},{count=5,deptno=20},{count=6,deptno=30}]
>   : {count:int, deptno:int} list

(*) End dummy.smli
