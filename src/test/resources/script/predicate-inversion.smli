(*
 * Test cases for predicate-to-generator inversion
 *)

Sys.set ("output", "tabular");
> val it = () : unit

val edges = [
 {x = 1, y = 2},
 {x = 2, y = 3}];
> x y
> - -
> 1 2
> 2 3
>
> val edges : {x:int, y:int} list

fun edge (x, y) = {x, y} elem edges;
> val edge = fn : int * int -> bool

(* Test 4: exists becomes iteration *)
(* TODO
let
  fun edge (x, y) = {x, y} elem edges
  fun hasEdgeFrom x = exists y where edge (x, y)
in
  from x where hasEdgeFrom x
end;
> val it = [1,2] : int list
*)

(* Test 5: Recursive predicate (transitive closure) *)
(* TODO
fun path (x, y) =
  edge (x, y)
  orelse exists z where path (x, z) andalso edge (z, y);
> val path = fn : int * int -> bool
*)

(* Expected: Should generate all reachable pairs
from (x, y) where path (x, y);
> val it = [(1,2),(1,3),(2,3)] : (int * int) list
*)

(* Test 6: Complex predicate with multiple clauses *)
let
  val employees = [
    {name = "Alice", dept = 10, salary = 50000},
    {name = "Bob", dept = 20, salary = 60000},
    {name = "Carol", dept = 10, salary = 70000}
  ]

  fun isHighPaidDept10 e =
    e elem employees
    andalso e.dept = 10
    andalso e.salary > 55000
in
  from e where isHighPaidDept10 e
end;
> dept name  salary
> ---- ----- ------
> 10   Carol 70000
>
> val it : {dept:int, name:string, salary:int} bag

(*) End predicate-inversion.smli
