(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *)

(*) Record and tuple are equivalent.
{1 = "a", 2 = true};
val it = ("a",true) : string * bool

("a", true);
val it = ("a",true) : string * bool

("a", true) = {1 = "a", 2 = true};
val it = true : bool

{1 = "a", 2 = true} = ("a", true);
val it = true : bool

("a", true) = {2 = true, 1 = "a"};
val it = true : bool

("a", true) = {2 = true, 1 = "b"};
val it = false : bool

("a", false) = {1 = "a", 2 = true};
val it = false : bool


(*) Empty record and empty tuple are equivalent, and of type 'unit'.
{};
val it = () : unit

();
val it = () : unit

{} = ();
val it = true : bool

() = {};
val it = true : bool


(*) Function with unit arg
fun one () = 1;
val one = fn : unit -> int

one ();
val it = 1 : int

one {};
val it = 1 : int

let
  fun one () = 1
in
  one ()
end;
val it = 1 : int


(*) A function with a type that is tricky to unparse correctly:
(*)   'a list -> ('a * 'a list) option
fun g [] = NONE
  | g (h :: t) = SOME (h, t);
val g = fn : 'a list -> ('a * 'a list) option


(*) Ditto:
(*)   'a list -> ('a * 'a list option) option
fun g [] = NONE
  | g (h :: t) = SOME (h, SOME t);
val g = fn : 'a list -> ('a * 'a list option) option


(*) Ditto:
(*)   'a list -> ('a option * 'a list option) option
fun g [] = NONE
  | g (h :: t) = SOME (SOME h, SOME t);
val g = fn : 'a list -> ('a option * 'a list option) option


(*) Pattern-match on record
fun f {a = c, b} = b + c;
val f = fn : {a:int, b:int} -> int

f {a = 5, b = 6};
val it = 11 : int


fun f2 {a = 1, b} = b * 2
  | f2 {a, b} = b * 3;
val f2 = fn : {a:int, b:int} -> int

f2 {a = 1, b = 6};
val it = 12 : int

f2 {a = 2, b = 6};
val it = 18 : int


fun f3 {a = 1, b} = b * 2;
val f3 = fn : {a:int, b:int} -> int

f3 {a = 1, b = 6};
val it = 12 : int


(*) The following correctly throws
(*)   unbound variable or constructor: a
(*) Disabled because error stacks made tests brittle.
(*) fun f4 {a = 1, b} = a + b;

(*) Variable with polymorphic type
val x = map;
val x = fn : ('a -> 'b) -> 'a list -> 'b list

x explode ["ab", "c"];
val it = [[#"a",#"b"],[#"c"]] : char list list


(*) Has polymorphic type
val rec len = fn x =>
    case x of head :: tail => 1 + (len tail)
            | [] => 0;
val len = fn : 'a list -> int


len [];
val it = 0 : int

len [1];
val it = 1 : int

len [1,2];
val it = 2 : int


map len (map explode ["ab", "", "cde"]);
val it = [2,0,3] : int list

map (fn s => len (explode s)) ["ab", "", "cde"];
val it = [2,0,3] : int list


(*) Type resolution involving record selectors
val emps =
  [{id = 100, name = "Fred", deptno = 10},
   {id = 101, name = "Velma", deptno = 20},
   {id = 102, name = "Shaggy", deptno = 30},
   {id = 103, name = "Scooby", deptno = 30}];
val emps =
  [{deptno=10,id=100,name="Fred"},{deptno=20,id=101,name="Velma"},
   {deptno=30,id=102,name="Shaggy"},{deptno=30,id=103,name="Scooby"}]
  : {deptno:int, id:int, name:string} list

map #deptno emps;
val it = [10,20,30,30] : int list

map #deptno (List.filter (fn e => #deptno e > 10) emps);
val it = [20,30,30] : int list

map #2 [(1,2),(3,1)];
val it = [2,1] : int list

List.filter #1 [(true,1),(false,2),(true,3)];
val it = [(true,1),(true,3)] : (bool * int) list

map #2 (List.filter #1 [(true,1),(false,2),(true,3)]);
val it = [1,3] : int list


(*) Should give
(*)  Error: duplicate variable in pattern(s): e
(*
fun in_ e [] = false
  | in_ e e :: tl = true
  | in_ e hd :: tl = in_ e tl
*)

(*) Should give
(*) Error: operator and operand don't agree [tycon mismatch]
(*)     operator domain: 'Z list list
(*)     operand:         (({id:'X; 'Y} -> 'X) * ([+ ty] * [+ ty] -> [+ ty])) list
(*)     in expression:
(*)       aggregate (((fn <pat> => <exp>),sum) :: nil)
(*
let
  fun foldl f start [] = start
    | foldl f start (hd :: tl) = foldl f (f (start, hd)) tl;
  fun map f [] = []
    | map f (hd :: tl) = (f hd) :: (map f tl);
  fun computeAgg (extractor, folder) list =
      foldl folder (map extractor list);
  fun aggregate aggFns list =
      map (computeAgg list) aggFns;
  fun sum (x, y) = x + y;
in
  aggregate [(#id, sum)] emps
end;
*)

(*) Record containing polymorphic functions:
(*)  val it = {a=fn,b=fn}
(*) : {a:'a list -> ('a * 'a list) option, b:'b list -> ('b * 'b list) option}
{a = fn x => case x of [] => NONE | (h :: t) => SOME (h, t),
 b = fn x => case x of [] => NONE | (h :: t) => SOME (h, t)};
val it = {a=fn,b=fn}
  : {a:'a list -> ('a * 'a list) option, b:'b list -> ('b * 'b list) option}


(*) Similar, expressed via 'fun'.
(* sml/nj gives:
stdIn:1.2-1.66 Warning: type vars not generalized because of
   value restriction are instantiated to dummy types (X1,X2,...)
val it = {a=1,b=fn} : {a:int, b:?.X1 list -> (?.X1 * ?.X1 list) option}
*)
let
  fun g [] = NONE
    | g (h :: t) = SOME (h, t)
in
  {a=1, b=g}
end;
val it = {a=1,b=fn} : {a:int, b:'a list -> ('a * 'a list) option}


(*) as above
{a = 1, b = let fun g [] = NONE | g (h :: t) = SOME (h, t) in g end};
val it = {a=1,b=fn} : {a:int, b:'a list -> ('a * 'a list) option}


(*) End type.sml
