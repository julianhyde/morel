(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *
 * Comprehensive transitive closure predicate inversion tests.
 * Based on Phase 5c test plan (.pm/PHASE-5C-TEST-PLAN.md).
 *)

(* ===================================================================
 * CATEGORY 1: CORRECTNESS TESTS (P0 - MANDATORY)
 * =================================================================== *)

(* Test 1.1: Basic Transitive Closure - REFERENCE TEST
 * This test already passes in such-that.smli:743
 * Duplicated here for completeness *)
val edges_1_1 = [{x=1,y=2},{x=2,y=3}];
fun edge_1_1 (x, y) = {x, y} elem edges_1_1;
fun path_1_1 (x, y) = edge_1_1 (x, y) orelse
  (exists z where path_1_1 (x, z) andalso edge_1_1 (z, y));
from p where path_1_1 p;
(*
[(1,2),(1,3),(2,3)]
*)

(* Test 1.2: Empty Base Case - Boundary Condition *)
val edges_1_2 = [] : (int * int) list;
fun edge_1_2 (x, y) = (x, y) elem edges_1_2;
fun path_1_2 (x, y) = edge_1_2 (x, y) orelse
  (exists z where path_1_2 (x, z) andalso edge_1_2 (z, y));
from p where path_1_2 p;
(*
[]
*)

(* Test 1.3: Single Edge - No Transitive Paths *)
val edges_1_3 = [(1, 2)];
fun edge_1_3 (x, y) = (x, y) elem edges_1_3;
fun path_1_3 (x, y) = edge_1_3 (x, y) orelse
  (exists z where path_1_3 (x, z) andalso edge_1_3 (z, y));
from p where path_1_3 p;
(*
[(1,2)]
*)

(* Test 1.4: Self-Loop - Reflexive Edge *)
val edges_1_4 = [(1, 1)];
fun edge_1_4 (x, y) = (x, y) elem edges_1_4;
fun path_1_4 (x, y) = edge_1_4 (x, y) orelse
  (exists z where path_1_4 (x, z) andalso edge_1_4 (z, y));
from p where path_1_4 p;
(*
[(1,1)]
*)

(* Test 1.5: Linear Chain - Multiple Iterations *)
val edges_1_5 = [(1,2), (2,3), (3,4), (4,5)];
fun edge_1_5 (x, y) = (x, y) elem edges_1_5;
fun path_1_5 (x, y) = edge_1_5 (x, y) orelse
  (exists z where path_1_5 (x, z) andalso edge_1_5 (z, y));
from p where path_1_5 p;
(*
[(1,2),(1,3),(1,4),(1,5),(2,3),(2,4),(2,5),(3,4),(3,5),(4,5)]
*)

(* Test 1.6: Cyclic Graph - CRITICAL Fixpoint Test *)
val edges_1_6 = [(1,2), (2,3), (3,1)];
fun edge_1_6 (x, y) = (x, y) elem edges_1_6;
fun path_1_6 (x, y) = edge_1_6 (x, y) orelse
  (exists z where path_1_6 (x, z) andalso edge_1_6 (z, y));
from p where path_1_6 p;
(*
[(1,1),(1,2),(1,3),(2,1),(2,2),(2,3),(3,1),(3,2),(3,3)]
*)

(* Test 1.7: Disconnected Components *)
val edges_1_7 = [(1,2), (3,4), (5,6)];
fun edge_1_7 (x, y) = (x, y) elem edges_1_7;
fun path_1_7 (x, y) = edge_1_7 (x, y) orelse
  (exists z where path_1_7 (x, z) andalso edge_1_7 (z, y));
from p where path_1_7 p;
(*
[(1,2),(3,4),(5,6)]
*)

(* Test 1.8: Diamond Pattern - Deduplication Test *)
val edges_1_8 = [(1,2), (1,3), (2,4), (3,4)];
fun edge_1_8 (x, y) = (x, y) elem edges_1_8;
fun path_1_8 (x, y) = edge_1_8 (x, y) orelse
  (exists z where path_1_8 (x, z) andalso edge_1_8 (z, y));
from p where path_1_8 p;
(*
[(1,2),(1,3),(1,4),(2,4),(3,4)]
*)

(* ===================================================================
 * CATEGORY 2: PATTERN VARIATION TESTS (P1)
 * =================================================================== *)

(* Test 2.1: Reversed orelse Order *)
val edges_2_1 = [(1,2), (2,3)];
fun edge_2_1 (x, y) = (x, y) elem edges_2_1;
fun path_2_1 (x, y) =
  (exists z where path_2_1 (x, z) andalso edge_2_1 (z, y)) orelse edge_2_1 (x, y);
from p where path_2_1 p;
(*
[(1,2),(1,3),(2,3)]
*)

(* Test 2.2: Different Variable Names *)
val edges_2_2 = [(1,2), (2,3)];
fun edge_2_2 (a, b) = (a, b) elem edges_2_2;
fun path_2_2 (a, b) = edge_2_2 (a, b) orelse
  (exists mid where path_2_2 (a, mid) andalso edge_2_2 (mid, b));
from p where path_2_2 p;
(*
[(1,2),(1,3),(2,3)]
*)

(* Test 2.3: Record-Based Edges *)
val edges_2_3 = [{src=1, dst=2}, {src=2, dst=3}];
fun edge_2_3 (x, y) = {src=x, dst=y} elem edges_2_3;
fun path_2_3 (x, y) = edge_2_3 (x, y) orelse
  (exists z where path_2_3 (x, z) andalso edge_2_3 (z, y));
from p where path_2_3 p;
(*
[(1,2),(1,3),(2,3)]
*)

(* Test 2.4: Alternative Conjunction Order *)
val edges_2_4 = [(1,2), (2,3)];
fun edge_2_4 (x, y) = (x, y) elem edges_2_4;
fun path_2_4 (x, y) = edge_2_4 (x, y) orelse
  (exists z where edge_2_4 (z, y) andalso path_2_4 (x, z));
from p where path_2_4 p;
(*
[(1,2),(1,3),(2,3)]
*)

(* ===================================================================
 * CATEGORY 3: PERFORMANCE TESTS (P1)
 * Note: These tests focus on correctness; timing measured separately
 * =================================================================== *)

(* Test 3.1: Small Graph (10 edges) *)
val edges_3_1 = [
  (1,2), (2,3), (3,4), (4,5), (5,6),
  (1,3), (2,4), (3,5), (4,6), (6,7)
];
fun edge_3_1 (x, y) = (x, y) elem edges_3_1;
fun path_3_1 (x, y) = edge_3_1 (x, y) orelse
  (exists z where path_3_1 (x, z) andalso edge_3_1 (z, y));
val result_3_1 = from p where path_3_1 p;
(* Check result count - should have ~35-40 paths *)
List.length result_3_1;
(*
37
*)

(* Test 3.2: Chain Graph Generator *)
fun genChain n =
  List.tabulate (n - 1, fn i => (i + 1, i + 2));

val edges_3_2 = genChain 15;
fun edge_3_2 (x, y) = (x, y) elem edges_3_2;
fun path_3_2 (x, y) = edge_3_2 (x, y) orelse
  (exists z where path_3_2 (x, z) andalso edge_3_2 (z, y));
val result_3_2 = from p where path_3_2 p;
List.length result_3_2;
(*
105
*)

(* Test 3.3: Dense Graph *)
fun genDense n =
  from i in List.tabulate (n, fn x => x + 1),
       j in List.tabulate (n, fn x => x + 1)
    where i <> j andalso i < j
    yield (i, j);

val edges_3_3 = genDense 8;
fun edge_3_3 (x, y) = (x, y) elem edges_3_3;
fun path_3_3 (x, y) = edge_3_3 (x, y) orelse
  (exists z where path_3_3 (x, z) andalso edge_3_3 (z, y));
val result_3_3 = from p where path_3_3 p;
List.length result_3_3;
(*
28
*)

(* ===================================================================
 * CATEGORY 4: EDGE CASE TESTS (P1)
 * =================================================================== *)

(* Test 4.1: Unsupported Pattern - Should Fall Back Gracefully *)
val edges_4_1 = [(1,2), (2,3)];
fun edge_4_1 (x, y) = (x, y) elem edges_4_1;
fun notPath (x, y) = edge_4_1 (x, y) andalso x <> y;
from p where notPath p;
(*
[(1,2),(2,3)]
*)

(* Test 4.2: Variable Name Shadowing *)
val x = 99;
val edges_4_2 = [(1,2), (2,3)];
fun edge_4_2 (x, y) = (x, y) elem edges_4_2;
fun path_4_2 (x, y) = edge_4_2 (x, y) orelse
  (exists z where path_4_2 (x, z) andalso edge_4_2 (z, y));
from p where path_4_2 p;
(*
[(1,2),(1,3),(2,3)]
*)

(* Test 4.3: Self-Loop with Additional Edges *)
val edges_4_3 = [(1, 1), (1, 2)];
fun edge_4_3 (x, y) = (x, y) elem edges_4_3;
fun path_4_3 (x, y) = edge_4_3 (x, y) orelse
  (exists z where path_4_3 (x, z) andalso edge_4_3 (z, y));
from p where path_4_3 p;
(*
[(1,1),(1,2)]
*)

(* Test 4.4: Large Number Range *)
val edges_4_4 = [(100, 200), (200, 300)];
fun edge_4_4 (x, y) = (x, y) elem edges_4_4;
fun path_4_4 (x, y) = edge_4_4 (x, y) orelse
  (exists z where path_4_4 (x, z) andalso edge_4_4 (z, y));
from p where path_4_4 p;
(*
[(100,200),(100,300),(200,300)]
*)

(* ===================================================================
 * CATEGORY 5: INTEGRATION TESTS (P2)
 * =================================================================== *)

(* Test 5.1: Combined with WHERE Filter *)
val edges_5_1 = [(1,2), (2,3), (3,4)];
fun edge_5_1 (x, y) = (x, y) elem edges_5_1;
fun path_5_1 (x, y) = edge_5_1 (x, y) orelse
  (exists z where path_5_1 (x, z) andalso edge_5_1 (z, y));
from (x, y) where path_5_1 (x, y) andalso x = 1;
(*
[(1,2),(1,3),(1,4)]
*)

(* Test 5.2: With ORDER BY Clause *)
val edges_5_2 = [(1,2), (2,3)];
fun edge_5_2 (x, y) = (x, y) elem edges_5_2;
fun path_5_2 (x, y) = edge_5_2 (x, y) orelse
  (exists z where path_5_2 (x, z) andalso edge_5_2 (z, y));
from p where path_5_2 p order p;
(*
[(1,2),(1,3),(2,3)]
*)

(* Test 5.3: With YIELD Clause *)
val edges_5_3 = [(1,2), (2,3)];
fun edge_5_3 (x, y) = (x, y) elem edges_5_3;
fun path_5_3 (x, y) = edge_5_3 (x, y) orelse
  (exists z where path_5_3 (x, z) andalso edge_5_3 (z, y));
from (x, y) where path_5_3 (x, y) yield {src = x, dst = y};
(*
[{dst=2,src=1},{dst=3,src=1},{dst=3,src=2}]
*)

(* Test 5.4: Nested Query *)
val edges_5_4 = [(1,2), (2,3)];
fun edge_5_4 (x, y) = (x, y) elem edges_5_4;
fun path_5_4 (x, y) = edge_5_4 (x, y) orelse
  (exists z where path_5_4 (x, z) andalso edge_5_4 (z, y));
from x in [1, 2]
  where exists (from (a, b) where path_5_4 (a, b) andalso a = x);
(*
[1,2]
*)

(* ===================================================================
 * CATEGORY 6: ADVANCED INTEGRATION TESTS (P1)
 * =================================================================== *)

(* Test 6.1: TC with Complex Filters *)
val edges_6_1 = [(1,2), (2,3), (5,6), (6,7), (7,8)];
fun edge_6_1 (x, y) = (x, y) elem edges_6_1;
fun path_6_1 (x, y) = edge_6_1 (x, y) orelse
  (exists z where path_6_1 (x, z) andalso edge_6_1 (z, y));
from (x, y) where path_6_1 (x, y) andalso x > 5;
(*
[(5,6),(5,7),(5,8),(6,7),(6,8),(7,8)]
*)

(* Test 6.2: TC with Nested Queries *)
val edges_6_2 = [(1,2), (2,3), (3,4)];
val bigSet = [2, 3, 4];
fun edge_6_2 (x, y) = (x, y) elem edges_6_2;
fun path_6_2 (x, y) = edge_6_2 (x, y) orelse
  (exists z where path_6_2 (x, z) andalso edge_6_2 (z, y));
from a in [1, 2, 3]
  where exists (from b in bigSet where path_6_2 (a, b));
(*
[1,2,3]
*)

(* Test 6.3: TC with Aggregate - count *)
val edges_6_3 = [(1,2), (2,3)];
fun edge_6_3 (x, y) = (x, y) elem edges_6_3;
fun path_6_3 (x, y) = edge_6_3 (x, y) orelse
  (exists z where path_6_3 (x, z) andalso edge_6_3 (z, y));
count (from p where path_6_3 p);
(*
3
*)

(* Test 6.4: TC with JOIN *)
val edges_6_4 = [(1,2), (2,3)];
val otherRel = [{x=2, y=10}, {x=3, y=20}];
fun edge_6_4 (x, y) = (x, y) elem edges_6_4;
fun path_6_4 (x, y) = edge_6_4 (x, y) orelse
  (exists z where path_6_4 (x, z) andalso edge_6_4 (z, y));
from p in (from pp where path_6_4 pp),
     q in otherRel
  where #2 p = #x q
  yield (#1 p, #y q);
(*
[(1,10),(1,20),(2,20)]
*)

(* ===================================================================
 * CATEGORY 7: ADVANCED EDGE CASES (P1)
 * =================================================================== *)

(* Test 7.1: Very Deep Chain (20+ nodes) *)
val edges_7_1 = List.tabulate (20, fn i => (i + 1, i + 2));
fun edge_7_1 (x, y) = (x, y) elem edges_7_1;
fun path_7_1 (x, y) = edge_7_1 (x, y) orelse
  (exists z where path_7_1 (x, z) andalso edge_7_1 (z, y));
val result_7_1 = from p where path_7_1 p;
List.length result_7_1;
(*
210
*)

(* Test 7.2: Highly Connected Graph (K_10 complete graph) *)
fun genCompleteGraph n =
  from i in List.tabulate (n, fn x => x + 1),
       j in List.tabulate (n, fn x => x + 1)
    where i <> j
    yield (i, j);

val edges_7_2 = genCompleteGraph 10;
fun edge_7_2 (x, y) = (x, y) elem edges_7_2;
fun path_7_2 (x, y) = edge_7_2 (x, y) orelse
  (exists z where path_7_2 (x, z) andalso edge_7_2 (z, y));
val result_7_2 = from p where path_7_2 p;
List.length result_7_2;
(*
90
*)

(* Test 7.3: Mixed Self-Loops and Cross-Edges *)
val edges_7_3 = [(1,1), (1,2), (2,2), (2,3), (3,3)];
fun edge_7_3 (x, y) = (x, y) elem edges_7_3;
fun path_7_3 (x, y) = edge_7_3 (x, y) orelse
  (exists z where path_7_3 (x, z) andalso edge_7_3 (z, y));
from p where path_7_3 p;
(*
[(1,1),(1,2),(1,3),(2,2),(2,3),(3,3)]
*)

(* Test 7.4: Multiple Disconnected Components *)
val edges_7_4 = [(1,2), (2,1), (3,4), (4,3), (5,5)];
fun edge_7_4 (x, y) = (x, y) elem edges_7_4;
fun path_7_4 (x, y) = edge_7_4 (x, y) orelse
  (exists z where path_7_4 (x, z) andalso edge_7_4 (z, y));
from p where path_7_4 p;
(*
[(1,1),(1,2),(2,1),(2,2),(3,3),(3,4),(4,3),(4,4),(5,5)]
*)

(* ===================================================================
 * CATEGORY 8: ADDITIONAL PATTERN VARIATIONS (P2)
 * =================================================================== *)

(* Test 8.1: Alternative Base Case Order (multiple orelse) *)
val edges_8_1a = [(1,2), (2,3)];
val edges_8_1b = [(3,4)];
fun edge_8_1a (x, y) = (x, y) elem edges_8_1a;
fun edge_8_1b (x, y) = (x, y) elem edges_8_1b;
fun path_8_1 (x, y) = edge_8_1b (x, y) orelse edge_8_1a (x, y) orelse
  (exists z where path_8_1 (x, z) andalso edge_8_1a (z, y));
from p where path_8_1 p;
(*
[(1,2),(1,3),(1,4),(2,3),(2,4),(3,4)]
*)

(* Test 8.2: Guard Condition in Base Case *)
val edges_8_2 = [(1,2), (2,3), (99,100), (100,101)];
fun edge_8_2 (x, y) = (x, y) elem edges_8_2;
fun path_8_2 (x, y) = (x < 100 andalso edge_8_2 (x, y)) orelse
  (exists z where path_8_2 (x, z) andalso edge_8_2 (z, y));
from p where path_8_2 p;
(*
[(1,2),(1,3),(2,3)]
*)

(* Test 8.3: Multiple exists with different variables *)
val edges_8_3 = [(1,2), (2,3), (3,4)];
fun edge_8_3 (x, y) = (x, y) elem edges_8_3;
fun path_8_3 (x, y) = edge_8_3 (x, y) orelse
  (exists z where edge_8_3 (x, z) andalso
    (exists w where edge_8_3 (z, w) andalso edge_8_3 (w, y)));
from p where path_8_3 p;
(*
[(1,2),(1,4),(2,3),(3,4)]
*)

(* ===================================================================
 * CATEGORY 9: ROBUSTNESS TESTS (P1)
 * =================================================================== *)

(* Test 9.1: Repeated TC Invocations in Same Query *)
val edges_9_1 = [(1,2), (2,3), (3,4)];
fun edge_9_1 (x, y) = (x, y) elem edges_9_1;
fun path_9_1 (x, y) = edge_9_1 (x, y) orelse
  (exists z where path_9_1 (x, z) andalso edge_9_1 (z, y));
from (x, y, z)
  where path_9_1 (x, y) andalso path_9_1 (y, z);
(*
[(1,2,3),(1,2,4),(1,3,4),(2,3,4)]
*)

(* Test 9.2: TC with Empty Base (explicit empty list) *)
val edges_9_2 = [] : (int * int) list;
fun edge_9_2 (x, y) = (x, y) elem edges_9_2;
fun path_9_2 (x, y) = edge_9_2 (x, y) orelse
  (exists z where path_9_2 (x, z) andalso edge_9_2 (z, y));
from p where path_9_2 p;
(*
[]
*)

(* Test 9.3: Large Cycle Detection *)
val edges_9_3 = [(1,2), (2,3), (3,4), (4,5), (5,6), (6,1)];
fun edge_9_3 (x, y) = (x, y) elem edges_9_3;
fun path_9_3 (x, y) = edge_9_3 (x, y) orelse
  (exists z where path_9_3 (x, z) andalso edge_9_3 (z, y));
val result_9_3 = from p where path_9_3 p;
List.length result_9_3;
(*
36
*)

(* ===================================================================
 * CATEGORY 10: PERFORMANCE CHARACTERISTICS (P1)
 * =================================================================== *)

(* Test 10.1: Iteration Count - Chain(15) should need ~15 iterations *)
val edges_10_1 = genChain 15;
fun edge_10_1 (x, y) = (x, y) elem edges_10_1;
fun path_10_1 (x, y) = edge_10_1 (x, y) orelse
  (exists z where path_10_1 (x, z) andalso edge_10_1 (z, y));
val result_10_1 = from p where path_10_1 p;
List.length result_10_1;
(*
105
*)

(* Test 10.2: Scalability Boundary - 50 node chain *)
val edges_10_2 = List.tabulate (49, fn i => (i + 1, i + 2));
fun edge_10_2 (x, y) = (x, y) elem edges_10_2;
fun path_10_2 (x, y) = edge_10_2 (x, y) orelse
  (exists z where path_10_2 (x, z) andalso edge_10_2 (z, y));
val result_10_2 = from p where path_10_2 p;
List.length result_10_2;
(*
1225
*)

(*) End transitive-closure.smli
