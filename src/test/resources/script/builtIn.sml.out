(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *)

(* Structures -------------------------------------------------- *)
General;
val it = {ignore=fn,op o=fn}
  : {ignore:'a -> unit, op o:('b -> 'c) * ('d -> 'b) -> 'd -> 'c}

Interact;
val it = {use=fn} : {use:string -> unit}

List;
val it =
  {all=fn,app=fn,at=fn,collate=fn,concat=fn,drop=fn,exists=fn,filter=fn,
   find=fn,foldl=fn,foldr=fn,getItem=fn,hd=fn,last=fn,length=fn,map=fn,
   mapPartial=fn,nil=[],nth=fn,null=fn,op @=fn,partition=fn,rev=fn,
   revAppend=fn,tabulate=fn,take=fn,tl=fn}
  : {all:('a -> bool) -> 'a list -> bool, app:('b -> unit) -> 'b list -> unit, at:'c list * 'c list -> 'c list, collate:('d * 'd -> order) -> 'd list * 'd list -> order, concat:'e list list -> 'e list, drop:'f list * int -> 'f list, exists:('g -> bool) -> 'g list -> bool, filter:('h -> bool) -> 'h list -> 'h list, find:('i -> bool) -> 'i list -> 'i option, foldl:('j * 'k -> 'k) -> 'k -> 'j list -> 'k, foldr:('l * 'm -> 'm) -> 'm -> 'l list -> 'm, getItem:'n list -> ('n * 'n list) option, hd:'o list -> 'o, last:'p list -> 'p, length:'q list -> int, map:('r -> 's) -> 'r list -> 's list, mapPartial:('t -> 'u option) -> 't list -> 'u list, nil:'v list, nth:'w list * int -> 'w, null:'x list -> bool, op @:'y list * 'y list -> 'y list, partition:('z -> bool) -> 'z list -> 'z list * 'z list, rev:'ba list -> 'ba list, revAppend:'bb list * 'bb list -> 'bb list, tabulate:int * (int -> 'bc) -> 'bc list, take:'bd list * int -> 'bd list, tl:'be list -> 'be list}

List.rev;
val it = fn : 'a list -> 'a list

List.rev [1,2,3];
val it = [3,2,1] : int list

Math;
val it =
  {acos=fn,asin=fn,atan=fn,atan2=fn,cos=fn,cosh=fn,e=2.7182817,exp=fn,ln=fn,
   log10=fn,pi=3.1415927,pow=fn,sin=fn,sinh=fn,sqrt=fn,tan=fn,tanh=fn}
  : {acos:real -> real, asin:real -> real, atan:real -> real, atan2:real * real -> real, cos:real -> real, cosh:real -> real, e:real, exp:real -> real, ln:real -> real, log10:real -> real, pi:real, pow:real * real -> real, sin:real -> real, sinh:real -> real, sqrt:real -> real, tan:real -> real, tanh:real -> real}

Option;
val it =
  {app=fn,compose=fn,composePartial=fn,filter=fn,flatten=fn,getOpt=fn,
   isSome=fn,map=fn,mapPartial=fn,valOf=fn}
  : {app:('a option -> unit) -> 'a option -> unit, compose:('b -> 'c) * ('d -> 'b option) -> 'd -> 'c option, composePartial:('e -> 'f option) * ('g -> 'e option) -> 'g -> 'f option, filter:('h -> bool) -> 'h -> 'h option, flatten:'i option option -> 'i option, getOpt:'j option * 'j -> 'j, isSome:'k option -> bool, map:('l -> 'm) -> 'l option -> 'm option, mapPartial:('n -> 'o option) -> 'n option -> 'o option, valOf:'p option -> 'p}

Option.compose;
val it = fn : ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option

String;
val it =
  {concat=fn,concatWith=fn,explode=fn,extract=fn,implode=fn,isPrefix=fn,
   isSubstring=fn,isSuffix=fn,map=fn,maxSize=2147483647,size=fn,str=fn,sub=fn,
   substring=fn,translate=fn}
  : {concat:string list -> string, concatWith:string -> string list -> string, explode:string -> char list, extract:string * int * int option -> string, implode:char list -> string, isPrefix:string -> string -> bool, isSubstring:string -> string -> bool, isSuffix:string -> string -> bool, map:(char -> char) -> string -> string, maxSize:int, size:string -> int, str:char -> string, sub:string * int -> char, substring:string * int * int -> string, translate:(char -> string) -> string -> string}

Relational;
val it =
  {count=fn,exists=fn,iterate=fn,max=fn,min=fn,notExists=fn,only=fn,sum=fn}
  : {count:'a list -> int, exists:'b list -> bool, iterate:'c list -> ('c list * 'c list -> 'c list) -> 'c list, max:'d list -> 'd, min:'e list -> 'e, notExists:'f list -> bool, only:'g list -> 'g, sum:'h list -> 'h}


(* Operators --------------------------------------------------- *)
2 + 3;
val it = 5 : int

2 + 3 * 4;
val it = 14 : int

Sys.plan ();
val it =
  "apply(fnValue +, argCode tuple(constant(2), apply(fnValue *, argCode tuple(constant(3), constant(4)))))"
  : string


fn x => x + 1;
val it = fn : int -> int

Sys.plan ();
val it = "match(x, apply(fnValue +, argCode tuple(get(name x), constant(1))))"
  : string


val nan = Real.posInf / Real.negInf;
val nan = nan : real


(* Datatypes --------------------------------------------------- *)

(*) datatype option
SOME 1;
val it = SOME 1 : int option

NONE;
val it = NONE : 'a option

SOME (SOME true);
val it = SOME SOME true : bool option option


(* General ----------------------------------------------------- *)

(*) op o - function composition
val plusOne = fn x => x + 1;
val plusOne = fn : int -> int

val timesTwo = fn x => x * 2;
val timesTwo = fn : int -> int

val plusThree = fn x => x + 3;
val plusThree = fn : int -> int

plusOne o timesTwo;
val it = fn : int -> int

(plusOne o timesTwo) 3;
val it = 7 : int

plusOne o timesTwo o plusThree;
val it = fn : int -> int

((plusOne o timesTwo) o plusThree) 3;
val it = 13 : int

(plusOne o (timesTwo o plusThree)) 3;
val it = 13 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue o, argCode tuple(get(name plusOne), apply(fnValue o, argCode tuple(get(name timesTwo), get(name plusThree))))), argCode constant(3))"
  : string


ignore;
val it = fn : 'a -> unit

ignore (1 + 2);
val it = () : unit

Sys.plan ();
val it =
  "apply(fnValue General.ignore, argCode apply(fnValue +, argCode tuple(constant(1), constant(2))))"
  : string


(* Interact ---------------------------------------------------- *)

(*) use - load source from a file
Interact.use;
val it = fn : string -> unit

use;
val it = fn : string -> unit


(* String ------------------------------------------------------ *)

(*) val maxSize : int
String.maxSize;
val it = 2147483647 : int

Sys.plan ();
val it = "constant(2147483647)" : string


(*) val size : string -> int
String.size;
val it = fn : string -> int

String.size "abc";
val it = 3 : int

String.size "";
val it = 0 : int

Sys.plan ();
val it = "apply(fnValue String.size, argCode constant())" : string


(*) val sub : string * int -> char
String.sub;
val it = fn : string * int -> char

String.sub("abc", 0);
val it = #"a" : char

String.sub("abc", 2);
val it = #"c" : char

String.sub("abc", 20);
uncaught exception Subscript [subscript out of bounds]

String.sub("abc", 3);
uncaught exception Subscript [subscript out of bounds]

String.sub("abc", ~1);
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue String.sub, argCode tuple(constant(abc), constant(-1)))"
  : string


(*) val extract: string * int * int option -> string
String.extract;
val it = fn : string * int * int option -> string

String.extract("abc", 1, NONE);
val it = "bc" : string

String.extract("abc", 1, SOME 2);
val it = "bc" : string

String.extract("abc", 3, NONE);
val it = "" : string

String.extract("abc", 3, SOME 0);
val it = "" : string

String.extract("abc", 4, NONE);
uncaught exception Subscript [subscript out of bounds]

String.extract("abc", ~1, NONE);
uncaught exception Subscript [subscript out of bounds]

String.extract("abc", 4, SOME 2);
uncaught exception Subscript [subscript out of bounds]

String.extract("abc", ~1, SOME 2);
uncaught exception Subscript [subscript out of bounds]

String.extract("abc", 1, SOME ~1);
uncaught exception Subscript [subscript out of bounds]

String.extract("abc", 1, SOME 99);
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue String.extract, argCode tuple(constant(abc), constant(1), apply(fnValue tyCon, argCode constant(99))))"
  : string


(*) val substring : string * int * int -> string
String.substring;
val it = fn : string * int * int -> string

String.substring("hello, world", 2, 7);
val it = "llo, wo" : string

String.substring("hello, world", 0, 1);
val it = "h" : string

String.substring("hello", 5, 0);
val it = "" : string

String.substring("hello", 1, 4);
val it = "ello" : string

String.substring("", 0, 0);
val it = "" : string

String.substring("hello", ~1, 0);
uncaught exception Subscript [subscript out of bounds]

String.substring("hello", 1, ~1);
uncaught exception Subscript [subscript out of bounds]

String.substring("hello", 1, 5);
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue String.substring, argCode tuple(constant(hello), constant(1), constant(5)))"
  : string


(*) val ^ : string * string -> string
"a" ^ "bc";
val it = "abc" : string

"a" ^ "";
val it = "a" : string

"a" ^ "bc" ^ "" ^ "def";
val it = "abcdef" : string

Sys.plan ();
val it =
  "apply(fnValue ^, argCode tuple(apply(fnValue ^, argCode tuple(apply(fnValue ^, argCode tuple(constant(a), constant(bc))), constant())), constant(def)))"
  : string


(*) val concat : string list -> string
String.concat;
val it = fn : string list -> string

String.concat ["a", "bc", "def"];
val it = "abcdef" : string

String.concat ["a"];
val it = "a" : string

String.concat [];
val it = "" : string

Sys.plan ();
val it = "apply(fnValue String.concat, argCode tuple)" : string


(*) val concatWith : string -> string list -> string
String.concatWith;
val it = fn : string -> string list -> string

String.concatWith "," ["a", "bc", "def"];
val it = "a,bc,def" : string

String.concatWith "," ["a"];
val it = "a" : string

String.concatWith "," ["", ""];
val it = "," : string

String.concatWith "," [];
val it = "" : string

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue String.concatWith, argCode constant(,)), argCode tuple)"
  : string


(*) val str : char -> string
String.str;
val it = fn : char -> string

String.str #"a";
val it = "a" : string

Sys.plan ();
val it = "apply(fnValue String.str, argCode constant(a))" : string


(*) val implode : char list -> string
String.implode;
val it = fn : char list -> string

String.implode [#"a", #"b", #"c"];
val it = "abc" : string

String.implode [];
val it = "" : string

Sys.plan ();
val it = "apply(fnValue String.implode, argCode tuple)" : string


(*) val explode : string -> char list
String.explode;
val it = fn : string -> char list

String.explode "abc";
val it = [#"a",#"b",#"c"] : char list

String.explode "";
val it = [] : char list

Sys.plan ();
val it = "apply(fnValue String.explode, argCode constant())" : string


(*) val map : (char -> char) -> string -> string
String.map;
val it = fn : (char -> char) -> string -> string

String.map (fn c => if c = #"a" then #"A" else if c = #"c" then #"C" else c) "abc";
val it = "AbC" : string

String.map (fn c => if c = #"a" then #"A" else if c = #"c" then #"C" else c) "";
val it = "" : string

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue String.map, argCode match(c, apply(fnCode match(true, constant(A), _, apply(fnCode match(true, constant(C), _, get(name c)), argCode apply(fnValue =, argCode tuple(get(name c), constant(c))))), argCode apply(fnValue =, argCode tuple(get(name c), constant(a)))))), argCode constant())"
  : string


(*) val translate : (char -> string) -> string -> string
String.translate;
val it = fn : (char -> string) -> string -> string

String.translate (fn c => if c = #"a" then "AA" else if c = #"c" then "CCC" else "-") "abc";
val it = "AA-CCC" : string

String.translate (fn c => if c = #"a" then "AA" else if c = #"c" then "CCC" else "-") "";
val it = "" : string

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue String.translate, argCode match(c, apply(fnCode match(true, constant(AA), _, apply(fnCode match(true, constant(CCC), _, constant(-)), argCode apply(fnValue =, argCode tuple(get(name c), constant(c))))), argCode apply(fnValue =, argCode tuple(get(name c), constant(a)))))), argCode constant())"
  : string


(*) val tokens : (char -> bool) -> string -> string list
(*) val fields : (char -> bool) -> string -> string list
(*) val isPrefix    : string -> string -> bool
String.isPrefix;
val it = fn : string -> string -> bool

String.isPrefix "he" "hello";
val it = true : bool

String.isPrefix "el" "hello";
val it = false : bool

String.isPrefix "lo" "hello";
val it = false : bool

String.isPrefix "bonjour" "hello";
val it = false : bool

String.isPrefix "el" "";
val it = false : bool

String.isPrefix "" "hello";
val it = true : bool

String.isPrefix "" "";
val it = true : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue String.isPrefix, argCode constant()), argCode constant())"
  : string


(*) val isSubstring : string -> string -> bool
String.isSubstring;
val it = fn : string -> string -> bool

String.isSubstring "he" "hello";
val it = true : bool

String.isSubstring "el" "hello";
val it = true : bool

String.isSubstring "lo" "hello";
val it = true : bool

String.isSubstring "bonjour" "hello";
val it = false : bool

String.isSubstring "el" "";
val it = false : bool

String.isSubstring "" "hello";
val it = true : bool

String.isSubstring "" "";
val it = true : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue String.isSubstring, argCode constant()), argCode constant())"
  : string


(*) val isSuffix    : string -> string -> bool
String.isSuffix;
val it = fn : string -> string -> bool

String.isSuffix "he" "hello";
val it = false : bool

String.isSuffix "el" "hello";
val it = false : bool

String.isSuffix "lo" "hello";
val it = true : bool

String.isSuffix "bonjour" "hello";
val it = false : bool

String.isSuffix "el" "";
val it = false : bool

String.isSuffix "" "hello";
val it = true : bool

String.isSuffix "" "";
val it = true : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue String.isSuffix, argCode constant()), argCode constant())"
  : string


(*) val compare : string * string -> order
(*) val collate : (char * char -> order) -> string * string -> order
(*) val <  : string * string -> bool
(*) val <= : string * string -> bool
(*) val >  : string * string -> bool
(*) val >= : string * string -> bool

(*) val toString : string -> String.string
(*) val scan       : (char, 'a) StringCvt.reader
(*)                    -> (string, 'a) StringCvt.reader
(*) val fromString : String.string -> string option
(*) val toCString : string -> String.string
(*) val fromCString : String.string -> string option

(* List -------------------------------------------------------- *)

(*) val nil : 'a list
List.nil;
val it = [] : 'a list

Sys.plan ();
val it = "constant([])" : string


(*) val null : 'a list -> bool
List.null;
val it = fn : 'a list -> bool

List.null [];
val it = true : bool

List.null [1];
val it = false : bool

Sys.plan ();
val it = "apply(fnValue List.null, argCode tuple(constant(1)))" : string


(*) val length : 'a list -> int
List.length;
val it = fn : 'a list -> int

List.length [];
val it = 0 : int

List.length [1,2];
val it = 2 : int

Sys.plan ();
val it = "apply(fnValue List.length, argCode tuple(constant(1), constant(2)))"
  : string


(*) val @ : 'a list * 'a list -> 'a list
List.at;
val it = fn : 'a list * 'a list -> 'a list

List.at ([1], [2, 3]);
val it = [1,2,3] : int list

List.at ([1], []);
val it = [1] : int list

List.at ([], [2]);
val it = [2] : int list

List.at ([], []);
val it = [] : 'a list

Sys.plan ();
val it = "apply(fnValue List.at, argCode tuple(tuple, tuple))" : string


[1] @ [2, 3];
val it = [1,2,3] : int list

[] @ [];
val it = [] : 'a list

Sys.plan ();
val it = "apply(fnValue List.at, argCode tuple(tuple, tuple))" : string


(*) val hd : 'a list -> 'a
List.hd;
val it = fn : 'a list -> 'a

List.hd [1,2,3];
val it = 1 : int

List.hd [];
uncaught exception Empty

Sys.plan ();
val it = "apply(fnValue List.hd, argCode tuple)" : string


(*) val tl : 'a list -> 'a list
List.tl;
val it = fn : 'a list -> 'a list

List.tl [1,2,3];
val it = [2,3] : int list

List.tl [];
uncaught exception Empty

Sys.plan ();
val it = "apply(fnValue List.tl, argCode tuple)" : string


(*) val last : 'a list -> 'a
List.last;
val it = fn : 'a list -> 'a

List.last [1,2,3];
val it = 3 : int

List.last [];
uncaught exception Empty

Sys.plan ();
val it = "apply(fnValue List.last, argCode tuple)" : string


(*) val getItem : 'a list -> ('a * 'a list) option
List.getItem;
val it = fn : 'a list -> ('a * 'a list) option

List.getItem [1,2,3];
val it = SOME (1,[2,3]) : (int * int list) option

List.getItem [1];
val it = SOME (1,[]) : (int * int list) option

Sys.plan ();
val it = "apply(fnValue List.getItem, argCode tuple(constant(1)))" : string


(*) val nth : 'a list * int -> 'a
List.nth;
val it = fn : 'a list * int -> 'a

List.nth ([1,2,3], 2);
val it = 3 : int

List.nth ([1], 0);
val it = 1 : int

List.nth ([1,2,3], 3);
uncaught exception Subscript [subscript out of bounds]

List.nth ([1,2,3], ~1);
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue List.nth, argCode tuple(tuple(constant(1), constant(2), constant(3)), constant(-1)))"
  : string


(*) val take : 'a list * int -> 'a list
List.take;
val it = fn : 'a list * int -> 'a list

List.take ([1,2,3], 0);
val it = [] : int list

List.take ([1,2,3], 1);
val it = [1] : int list

List.take ([1,2,3], 3);
val it = [1,2,3] : int list

List.take ([1,2,3], 4);
uncaught exception Subscript [subscript out of bounds]

List.take ([1,2,3], ~1);
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue List.take, argCode tuple(tuple(constant(1), constant(2), constant(3)), constant(-1)))"
  : string


(*) val drop : 'a list * int -> 'a list
List.drop;
val it = fn : 'a list * int -> 'a list

List.drop ([1,2,3], 0);
val it = [1,2,3] : int list

List.drop ([1,2,3], 1);
val it = [2,3] : int list

List.drop ([1,2,3], 3);
val it = [] : int list

Sys.plan ();
val it =
  "apply(fnValue List.drop, argCode tuple(tuple(constant(1), constant(2), constant(3)), constant(3)))"
  : string


(*) val rev : 'a list -> 'a list
List.rev;
val it = fn : 'a list -> 'a list

List.rev [1,2,3];
val it = [3,2,1] : int list

List.rev [2,1];
val it = [1,2] : int list

List.rev [1];
val it = [1] : int list

List.rev [];
val it = [] : 'a list

Sys.plan ();
val it = "apply(fnValue List.rev, argCode tuple)" : string


(*) val concat : 'a list list -> 'a list
List.concat;
val it = fn : 'a list list -> 'a list

List.concat [[1],[2,3],[4,5,6]];
val it = [1,2,3,4,5,6] : int list

List.concat [[1],[],[4,5,6]];
val it = [1,4,5,6] : int list

List.concat [[],[],[]];
val it = [] : 'a list

List.concat [];
val it = [] : 'a list

Sys.plan ();
val it = "apply(fnValue List.concat, argCode tuple)" : string


(*) val revAppend : 'a list * 'a list -> 'a list
List.revAppend;
val it = fn : 'a list * 'a list -> 'a list

List.revAppend ([1,2],[3,4,5]);
val it = [2,1,3,4,5] : int list

List.revAppend ([1],[3,4,5]);
val it = [1,3,4,5] : int list

List.revAppend ([],[3,4,5]);
val it = [3,4,5] : int list

List.revAppend ([1,2],[]);
val it = [2,1] : int list

List.revAppend ([],[]);
val it = [] : 'a list

Sys.plan ();
val it = "apply(fnValue List.revAppend, argCode tuple(tuple, tuple))" : string


(*) val app : ('a -> unit) -> 'a list -> unit
List.app;
val it = fn : ('a -> unit) -> 'a list -> unit

List.app (fn x => ignore (x + 2)) [2,3,4];
val it = () : unit

List.app (fn x => ignore (x + 2)) [];
val it = () : unit

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.app, argCode match(x, apply(fnValue General.ignore, argCode apply(fnValue +, argCode tuple(get(name x), constant(2)))))), argCode tuple)"
  : string


(*) val map : ('a -> 'b) -> 'a list -> 'b list
List.map;
val it = fn : ('a -> 'b) -> 'a list -> 'b list

List.map (fn x => x + 1) [1,2,3];
val it = [2,3,4] : int list

List.map (fn x => x + 1) [];
val it = [] : int list

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.map, argCode match(x, apply(fnValue +, argCode tuple(get(name x), constant(1))))), argCode tuple)"
  : string


(*) map is alias for List.map
map;
val it = fn : ('a -> 'b) -> 'a list -> 'b list

map (fn x => x) [];
val it = [] : 'a list

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.map, argCode match(x, get(name x))), argCode tuple)"
  : string


(*) val mapPartial : ('a -> 'b option) -> 'a list -> 'b list
List.mapPartial;
val it = fn : ('a -> 'b option) -> 'a list -> 'b list

List.mapPartial (fn x => if x mod 2 = 0 then NONE else SOME (x + 1)) [1,2,3,5,8];
val it = [2,4,6] : int list

List.mapPartial (fn x => if x mod 2 = 0 then NONE else SOME (x + 1)) [];
val it = [] : int list

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.mapPartial, argCode match(x, apply(fnCode match(true, constant([NONE]), _, apply(fnValue tyCon, argCode apply(fnValue +, argCode tuple(get(name x), constant(1))))), argCode apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(2))), constant(0)))))), argCode tuple)"
  : string


(*) val find : ('a -> bool) -> 'a list -> 'a option
List.find;
val it = fn : ('a -> bool) -> 'a list -> 'a option

List.find (fn x => x mod 7 = 0) [2,3,5,8,13,21,34];
val it = SOME 21 : int option

List.find (fn x => x mod 11 = 0) [2,3,5,8,13,21,34];
val it = NONE : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.find, argCode match(x, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(11))), constant(0))))), argCode tuple(constant(2), constant(3), constant(5), constant(8), constant(13), constant(21), constant(34)))"
  : string


(*) val filter : ('a -> bool) -> 'a list -> 'a list
List.filter;
val it = fn : ('a -> bool) -> 'a list -> 'a list

List.filter (fn x => x mod 2 = 0) [0,1,2,3,4,5];
val it = [0,2,4] : int list

List.filter (fn x => x mod 2 = 0) [1,3];
val it = [] : int list

List.filter (fn x => x mod 2 = 0) [];
val it = [] : int list

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.filter, argCode match(x, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(2))), constant(0))))), argCode tuple)"
  : string


(*) val partition : ('a -> bool) -> 'a list -> 'a list * 'a list
List.partition;
val it = fn : ('a -> bool) -> 'a list -> 'a list * 'a list

List.partition (fn x => x mod 2 = 0) [0,1,2,3,4,5];
val it = ([0,2,4],[1,3,5]) : int list * int list

List.partition (fn x => x mod 2 = 0) [1];
val it = ([],[1]) : int list * int list

List.partition (fn x => x mod 2 = 0) [];
val it = ([],[]) : int list * int list

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.partition, argCode match(x, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(2))), constant(0))))), argCode tuple)"
  : string


(*) val foldl : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
List.foldl;
val it = fn : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b

List.foldl (fn (a, b) => a + b) 0 [1,2,3];
val it = 6 : int

List.foldl (fn (a, b) => a + b) 0 [];
val it = 0 : int

List.foldl (fn (a, b) => b) 0 [1,2,3];
val it = 0 : int

List.foldl (fn (a, b) => a - b) 0 [1,2,3,4];
val it = 2 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnCode apply(fnValue List.foldl, argCode match(v0, apply(fnCode match((a, b), apply(fnValue -, argCode tuple(get(name a), get(name b)))), argCode get(name v0)))), argCode constant(0)), argCode tuple(constant(1), constant(2), constant(3), constant(4)))"
  : string


(*) val foldr : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b
List.foldr;
val it = fn : ('a * 'b -> 'b) -> 'b -> 'a list -> 'b

List.foldr (fn (a, b) => a + b) 0 [1,2,3];
val it = 6 : int

List.foldr (fn (a, b) => a + b) 0 [];
val it = 0 : int

List.foldr (fn (a, b) => b) 0 [1,2,3];
val it = 0 : int

List.foldr (fn (a, b) => a - b) 0 [1,2,3,4];
val it = ~2 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnCode apply(fnValue List.foldr, argCode match(v0, apply(fnCode match((a, b), apply(fnValue -, argCode tuple(get(name a), get(name b)))), argCode get(name v0)))), argCode constant(0)), argCode tuple(constant(1), constant(2), constant(3), constant(4)))"
  : string


(*) val exists : ('a -> bool) -> 'a list -> bool
List.exists;
val it = fn : ('a -> bool) -> 'a list -> bool

List.exists (fn x => x mod 2 = 0) [1,3,5];
val it = false : bool

List.exists (fn x => x mod 2 = 0) [2,4,6];
val it = true : bool

List.exists (fn x => x mod 2 = 0) [1,2,3];
val it = true : bool

List.exists (fn x => x mod 2 = 0) [];
val it = false : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.exists, argCode match(x, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(2))), constant(0))))), argCode tuple)"
  : string


(*) val all : ('a -> bool) -> 'a list -> bool
List.all;
val it = fn : ('a -> bool) -> 'a list -> bool

List.all (fn x => x mod 2 = 0) [1,3,5];
val it = false : bool

List.all (fn x => x mod 2 = 0) [2,4,6];
val it = true : bool

List.all (fn x => x mod 2 = 0) [1,2,3];
val it = false : bool

List.all (fn x => x mod 2 = 0) [];
val it = true : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.all, argCode match(x, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(2))), constant(0))))), argCode tuple)"
  : string


(*) val tabulate : int * (int -> 'a) -> 'a list
List.tabulate;
val it = fn : int * (int -> 'a) -> 'a list

List.tabulate (5, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
val it = [1,1,2,6,24] : int list

List.tabulate (1, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
val it = [1] : int list

List.tabulate (0, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
val it = [] : int list

List.tabulate (~1, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
uncaught exception Size

Sys.plan ();
val it =
  "apply(fnValue List.tabulate, argCode tuple(constant(-1), let1(matchCode match(fact, match(n, apply(fnCode match(true, constant(1), _, apply(fnValue *, argCode tuple(get(name n), apply(fnCode link, argCode apply(fnValue -, argCode tuple(get(name n), constant(1))))))), argCode apply(fnValue =, argCode tuple(get(name n), constant(0)))))), resultCode get(name fact))))"
  : string


(*) val collate : ('a * 'a -> order) -> 'a list * 'a list -> order
List.collate;
val it = fn : ('a * 'a -> order) -> 'a list * 'a list -> order

List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1, 2,3], [1,3,4]);
val it = LESS : order

List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1,2,3], [1,2,2]);
val it = GREATER : order

List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1,2,3], [1,2]);
val it = GREATER : order

List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1,2,3], [1,2,3,4]);
val it = LESS : order

List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([1,2,3], []);
val it = GREATER : order

List.collate (fn (x, y) => if x < y then LESS else if x = y then EQUAL else GREATER) ([], []);
val it = EQUAL : order

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue List.collate, argCode match(v0, apply(fnCode match((x, y), apply(fnCode match(true, constant([LESS]), _, apply(fnCode match(true, constant([EQUAL]), _, constant([GREATER])), argCode apply(fnValue =, argCode tuple(get(name x), get(name y))))), argCode apply(fnValue <, argCode tuple(get(name x), get(name y))))), argCode get(name v0)))), argCode tuple(tuple, tuple))"
  : string


(* Math -------------------------------------------------------- *)
(* The signature MATH specifies basic mathematical constants, the square root
   function, and trigonometric, hyperbolic, exponential, and logarithmic
   functions based on a real type. The functions defined here have roughly the
   same semantics as their counterparts in ISO C's math.h.

   In the functions below, unless specified otherwise, if any argument is a NaN,
   the return value is a NaN. In a list of rules specifying the behavior of a
   function in special cases, the first matching rule defines the semantics. *)

(* "acos x" returns the arc cosine of x. acos is the inverse of cos.
   Its result is guaranteed to be in the closed interval [0, pi]. If
   the magnitude of x exceeds 1.0, returns NaN. *)
Math.acos;
val it = fn : real -> real

Math.acos 1.0;
val it = 0.0 : real

Sys.plan ();
val it = "apply(fnValue Math.acos, argCode constant(1.0))" : string

List.map (fn x => (x, Math.acos x))
  [1.0, 0.0, ~0.0, ~1.0, 0.5, Math.sqrt 0.5, 2.0, Real.posInf, Real.negInf, nan];
val it =
  [(1.0,0.0),(0.0,1.5707964),(~0.0,1.5707964),(~1.0,3.1415927),(0.5,1.0471976),
   (0.70710677,0.7853982),(2.0,nan),(inf,nan),(~inf,nan),(nan,nan)]
  : (real * real) list


(* "asin x" returns the arc sine of x. asin is the inverse of sin. Its
   result is guaranteed to be in the closed interval [-pi / 2, pi / 2].
   If the magnitude of x exceeds 1.0, returns NaN. *)
Math.asin;
val it = fn : real -> real

Math.asin 1.0;
val it = 1.5707964 : real

Sys.plan ();
val it = "apply(fnValue Math.asin, argCode constant(1.0))" : string

List.map (fn x => (x, Math.asin x))
  [1.0, 0.0, ~0.0, ~1.0, 0.5, Math.sqrt 0.5, 2.0, Real.posInf, Real.negInf, nan];
val it =
  [(1.0,1.5707964),(0.0,0.0),(~0.0,~0.0),(~1.0,~1.5707964),(0.5,0.5235988),
   (0.70710677,0.7853981),(2.0,nan),(inf,nan),(~inf,nan),(nan,nan)]
  : (real * real) list


(* "atan x" returns the arc tangent of x. atan is the inverse of
   tan. For finite arguments, the result is guaranteed to be in the
   open interval (-pi / 2, pi / 2). If x is +infinity, it returns pi / 2;
   if x is -infinity, it returns -pi / 2. *)
Math.atan;
val it = fn : real -> real

Math.atan 0.0;
val it = 0.0 : real

Sys.plan ();
val it = "apply(fnValue Math.atan, argCode constant(0.0))" : string

List.map (fn x => (x, Math.atan x))
  [1.0, 0.0, ~0.0, ~1.0, 0.5, Math.sqrt 0.5, 2.0, Real.posInf, Real.negInf, nan];
val it =
  [(1.0,0.7853982),(0.0,0.0),(~0.0,~0.0),(~1.0,~0.7853982),(0.5,0.4636476),
   (0.70710677,0.6154797),(2.0,1.1071488),(inf,1.5707964),(~inf,~1.5707964),
   (nan,nan)] : (real * real) list


(* "atan2 (y, x)" returns the arc tangent of (y / x) in the closed
   interval [-pi, pi], corresponding to angles within +-180
   degrees. The quadrant of the resulting angle is determined using
   the signs of both x and y, and is the same as the quadrant of the
   point (x, y). When x = 0, this corresponds to an angle of 90
   degrees, and the result is (real (sign y)) * pi / 2.0. It holds
   that
     sign (cos (atan2 (y, x))) = sign (x)
   and
     sign (sin (atan2 (y, x))) = sign (y)
   except for inaccuracies incurred by the finite precision of real
   and the approximation algorithms used to compute the mathematical
   functions.  Rules for exceptional cases are specified in the
   following table.

   y                 x         atan2(y, x)
   ================= ========= ==========
   +-0               0 < x     +-0
   +-0               +0        +-0
   +-0               x < 0     +-pi
   +-0               -0        +-pi
   y, 0 < y          +-0       pi/2
   y, y < 0          +-0       -pi/2
   +-y, finite y > 0 +infinity +-0
   +-y, finite y > 0 -infinity +-pi
   +-infinity        finite x  +-pi/2
   +-infinity        +infinity +-pi/4
   +-infinity        -infinity +-3pi/4
*)
Math.atan2;
val it = fn : real * real -> real

Math.atan2 (0.0, 1.0);
val it = 0.0 : real

Sys.plan ();
val it =
  "apply(fnValue Math.atan2, argCode tuple(constant(0.0), constant(1.0)))"
  : string

List.map (fn x => (x, Math.atan2 (x, 1.0)))
  [1.0, 0.0, ~1.0, 0.5, Math.sqrt 0.5, 2.0, Real.posInf, Real.negInf, nan];
val it =
  [(1.0,0.7853982),(0.0,0.0),(~1.0,~0.7853982),(0.5,0.4636476),
   (0.70710677,0.6154797),(2.0,1.1071488),(inf,1.5707964),(~inf,~1.5707964),
   (nan,nan)] : (real * real) list

List.map (fn (x, y) => (x, y, Math.atan2 (x, y)))
  [(0.0, 1.0), (~0.0, 1.0),
   (0.0, 0.0), (~0.0, 0.0),
   (0.0, ~1.0), (~0.0, ~1.0),
   (2.5, 0.0), (2.5, ~0.0),
   (~2.5, 0.0), (~2.5, ~0.0),
   (3.0, Real.posInf), (~3.0, Real.posInf),
   (4.0, Real.negInf), (~4.0, Real.negInf),
   (Real.posInf, 5.0), (Real.negInf, 5.0),
   (Real.posInf, Real.posInf), (Real.negInf, Real.posInf),
   (Real.posInf, Real.negInf), (Real.negInf, Real.negInf),
   (0.0, nan), (1.0, nan), (~1.0, nan), (Real.posInf, nan), (Real.negInf, nan),
   (nan, 0.0), (nan, 1.0), (nan, ~1.0), (nan, Real.posInf), (nan, Real.negInf),
   (nan, nan)];
val it =
  [(0.0,1.0,0.0),(~0.0,1.0,~0.0),(0.0,0.0,0.0),(~0.0,0.0,~0.0),
   (0.0,~1.0,3.1415927),(~0.0,~1.0,~3.1415927),(2.5,0.0,1.5707964),
   (2.5,~0.0,1.5707964),(~2.5,0.0,~1.5707964),(~2.5,~0.0,~1.5707964),
   (3.0,inf,0.0),(~3.0,inf,~0.0),...] : (real * real * real) list


(* "cos x" returns the cosine of x, measured in radians. If x is an infinity,
   returns NaN. *)
Math.cos;
val it = fn : real -> real

Math.cos 0.0;
val it = 1.0 : real

Sys.plan ();
val it = "apply(fnValue Math.cos, argCode constant(0.0))" : string

List.map (fn x => (x, Math.cos x))
  [0.0, ~0.0, Math.pi, Math.pi * 0.5, ~Math.pi, Math.pi * 5.0, Real.posInf, Real.negInf, nan];
val it =
  [(0.0,1.0),(~0.0,1.0),(3.1415927,~1.0),(1.5707964,~4.371139E-8),
   (~3.1415927,~1.0),(15.707964,~1.0),(inf,nan),(~inf,nan),(nan,nan)]
  : (real * real) list


(* "cosh x" returns the hyperbolic cosine of x, that is, (e(x) + e(-x)) / 2.
   It has the properties cosh +-0 = 1, cosh +-infinity = +-infinity. *)
Math.cosh;
val it = fn : real -> real

Math.cosh 0.0;
val it = 1.0 : real

Sys.plan ();
val it = "apply(fnValue Math.cosh, argCode constant(0.0))" : string

List.map (fn x => (x, Math.cosh x))
  [0.0, ~0.0, 1.0, Real.posInf, Real.negInf, nan];
val it = [(0.0,1.0),(~0.0,1.0),(1.0,1.5430807),(inf,inf),(~inf,inf),(nan,nan)]
  : (real * real) list


(* "val e : real" The base e (2.718281828...) of the natural logarithm. *)
Math.e;
val it = 2.7182817 : real

Sys.plan ();
val it = "constant(2.7182817)" : string


(* "exp x" returns e(x), i.e., e raised to the x(th) power. If x is
   +infinity, it returns +infinity; if x is -infinity, it returns 0. *)
Math.exp;
val it = fn : real -> real

Math.exp 0.0;
val it = 1.0 : real

Sys.plan ();
val it = "apply(fnValue Math.exp, argCode constant(0.0))" : string

List.map (fn x => (x, Math.exp x))
  [0.0, ~0.0, 1.0, ~2.0, Real.posInf, Real.negInf, nan];
val it =
  [(0.0,1.0),(~0.0,1.0),(1.0,2.7182817),(~2.0,0.13533528),(inf,inf),(~inf,0.0),
   (nan,nan)] : (real * real) list


(* "ln x" returns the natural logarithm (base e) of x. If x < 0,
   returns NaN; if x = 0, returns -infinity; if x is infinity, returns
   infinity. *)
Math.ln;
val it = fn : real -> real

Math.ln 1.0;
val it = 0.0 : real

Sys.plan ();
val it = "apply(fnValue Math.ln, argCode constant(1.0))" : string

List.map (fn x => (x, Math.ln x))
  [1.0, 2.718, Math.e, 0.0, ~0.0, ~3.0, Real.posInf, Real.negInf, nan];
val it =
  [(1.0,0.0),(2.718,0.9998963),(2.7182817,0.99999994),(0.0,~inf),(~0.0,~inf),
   (~3.0,nan),(inf,inf),(~inf,nan),(nan,nan)] : (real * real) list


(* "log10 x" returns the decimal logarithm (base 10) of x. If x < 0,
   returns NaN; if x = 0, returns -infinity; if x is infinity, returns
   infinity. *)
Math.log10;
val it = fn : real -> real

Math.log10 1.0;
val it = 0.0 : real

Sys.plan ();
val it = "apply(fnValue Math.log10, argCode constant(1.0))" : string

List.map (fn x => (x, Math.log10 x))
  [1.0, 10.0, 1000.0, 0.0, ~0.0, ~3.0, Real.posInf, Real.negInf, nan];
val it =
  [(1.0,0.0),(10.0,1.0),(1000.0,3.0),(0.0,~inf),(~0.0,~inf),(~3.0,nan),
   (inf,inf),(~inf,nan),(nan,nan)] : (real * real) list


(* "val pi : real" The constant pi (3.141592653...). *)
Math.pi;
val it = 3.1415927 : real

Sys.plan ();
val it = "constant(3.1415927)" : string


(* "pow (x, y)" returns x(y), i.e., x raised to the y(th) power. For
   finite x and y, this is well-defined when x > 0, or when x < 0 and
   y is integral. Rules for exceptional cases are specified below.

   x                 y                             pow(x,y)
   ================= ============================= ==========
   x, including NaN  0                             1
   |x| > 1           +infinity                     +infinity
   |x| < 1           +infinity                     +0
   |x| > 1           -infinity                     +0
   |x| < 1           -infinity                     +infinity
   +infinity         y > 0                         +infinity
   +infinity         y < 0                         +0
   -infinity         y > 0, odd integer            -infinity
   -infinity         y > 0, not odd integer        +infinity
   -infinity         y < 0, odd integer            -0
   -infinity         y < 0, not odd integer        +0
   x                 NaN                           NaN
   NaN               y <> 0                        NaN
   +-1               +-infinity                    NaN
   finite x < 0      finite non-integer y          NaN
   +-0               y < 0, odd integer            +-infinity
   +-0               finite y < 0, not odd integer +infinity
   +-0               y > 0, odd integer            +-0
   +-0               y > 0, not odd integer        +0
*)
Math.pow;
val it = fn : real * real -> real

Math.pow (2.0, 3.0);
val it = 8.0 : real

Math.pow (2.0, ~4.0);
val it = 0.0625 : real

Math.pow (100.0, 0.5);
val it = 10.0 : real

Sys.plan ();
val it =
  "apply(fnValue Math.pow, argCode tuple(constant(100.0), constant(0.5)))"
  : string

List.map (fn (x, y) => (x, y, Math.pow (x, y)))
  [(0.0, 0.0), (nan, 0.0),
   (2.0, Real.posInf), (~2.0, Real.posInf),
   (0.5, Real.posInf), (~0.5, Real.posInf),
   (3.0, Real.negInf), (~3.0, Real.negInf),
   (0.25, Real.negInf), (~0.25, Real.negInf),
   (Real.posInf, 0.5),
   (Real.posInf, ~0.5),
   (Real.negInf, 7.0),
   (Real.negInf, 8.0),
   (Real.negInf, ~7.0),
   (Real.negInf, ~8.0),
   (9.5, nan),
   (nan, 9.6),
   (1.0, Real.posInf), (~1.0, Real.posInf), (1.0, Real.negInf), (~1.0, Real.negInf),
   (~9.8, 2.5),
   (0.0, ~9.0), (~0.0, ~9.0),
   (0.0, ~10.0), (~0.0, ~10.0),
   (0.0, 11.0), (~0.0, 11.0),
   (0.0, 12.0), (~0.0, 12.0)];
val it =
  [(0.0,0.0,1.0),(nan,0.0,1.0),(2.0,inf,inf),(~2.0,inf,inf),(0.5,inf,0.0),
   (~0.5,inf,0.0),(3.0,~inf,0.0),(~3.0,~inf,0.0),(0.25,~inf,inf),
   (~0.25,~inf,inf),(inf,0.5,inf),(inf,~0.5,0.0),...]
  : (real * real * real) list


(* "sin x" returns the sine of x, measured in radians.
   If x is an infinity, returns NaN. *)
Math.sin;
val it = fn : real -> real

Math.sin 0.0;
val it = 0.0 : real

Sys.plan ();
val it = "apply(fnValue Math.sin, argCode constant(0.0))" : string

List.map (fn x => (x, Math.sin x))
  [0.0, ~0.0, Math.pi, Math.pi * 0.5, ~Math.pi, Math.pi * 5.0, Real.posInf, Real.negInf, nan];
val it =
  [(0.0,0.0),(~0.0,~0.0),(3.1415927,~8.742278E-8),(1.5707964,1.0),
   (~3.1415927,8.742278E-8),(15.707964,~6.755325E-7),(inf,nan),(~inf,nan),
   (nan,nan)] : (real * real) list


(* "sinh x" returns the hyperbolic sine of x, that is, (e(x) - e(-x)) / 2.
   It has the property sinh +-0 = +-0, sinh +-infinity = +-infinity. *)
Math.sinh;
val it = fn : real -> real

Math.sinh 0.0;
val it = 0.0 : real

Sys.plan ();
val it = "apply(fnValue Math.sinh, argCode constant(0.0))" : string

List.map (fn x => (x, Math.sinh x))
  [0.0, ~0.0, 1.0, Real.posInf, Real.negInf, nan];
val it =
  [(0.0,0.0),(~0.0,~0.0),(1.0,1.1752012),(inf,inf),(~inf,~inf),(nan,nan)]
  : (real * real) list


(* "sqrt x" returns the square root of x. sqrt (~0.0) = ~0.0.
   If x < 0, returns NaN. *)
Math.sqrt;
val it = fn : real -> real

Math.sqrt 4.0;
val it = 2.0 : real

Sys.plan ();
val it = "apply(fnValue Math.sqrt, argCode constant(4.0))" : string

List.map (fn x => (x, Math.sqrt x))
  [4.0, 0.0, ~0.0, ~9.0, Real.posInf, Real.negInf, nan];
val it =
  [(4.0,2.0),(0.0,0.0),(~0.0,~0.0),(~9.0,nan),(inf,inf),(~inf,nan),(nan,nan)]
  : (real * real) list


(* "tan x" returns the tangent of x, measured in radians. If x is an
   infinity, returns NaN. Produces infinities at various finite values,
   roughly corresponding to the singularities of the tangent function. *)
Math.tan;
val it = fn : real -> real

Math.tan 0.0;
val it = 0.0 : real

Sys.plan ();
val it = "apply(fnValue Math.tan, argCode constant(0.0))" : string

List.map (fn x => (x, Math.tan x))
  [0.0, ~0.0, Math.pi, Math.pi * 0.5, ~Math.pi, Math.pi * 5.0, Real.posInf, Real.negInf, nan];
val it =
  [(0.0,0.0),(~0.0,~0.0),(3.1415927,8.742278E-8),(1.5707964,~2.2877332E7),
   (~3.1415927,~8.742278E-8),(15.707964,6.755325E-7),(inf,nan),(~inf,nan),
   (nan,nan)] : (real * real) list


(* "tanh x" returns the hyperbolic tangent of x, that is, (sinh x) / (cosh x).
   It has the properties tanh +-0 = +-0, tanh +-infinity = +-1. *)
Math.tanh;
val it = fn : real -> real

Math.tanh 0.0;
val it = 0.0 : real

Sys.plan ();
val it = "apply(fnValue Math.tanh, argCode constant(0.0))" : string

List.map (fn x => (x, Math.tanh x))
  [0.0, ~0.0, 1.0, Real.posInf, Real.negInf, nan];
val it =
  [(0.0,0.0),(~0.0,~0.0),(1.0,0.7615942),(inf,1.0),(~inf,~1.0),(nan,nan)]
  : (real * real) list


(* Option ------------------------------------------------------ *)
(*) val getOpt : 'a option * 'a -> 'a
Option.getOpt (SOME 1, 2);
val it = 1 : int

Option.getOpt (NONE, 2);
val it = 2 : int

Sys.plan ();
val it =
  "apply(fnValue Option.getOpt, argCode tuple(constant([NONE]), constant(2)))"
  : string


(*) val isSome : 'a option -> bool
Option.isSome (SOME 1);
val it = true : bool

Option.isSome NONE;
val it = false : bool

Sys.plan ();
val it = "apply(fnValue Option.isSome, argCode constant([NONE]))" : string


(*) val valOf : 'a option -> 'a
Option.valOf (SOME 1);
val it = 1 : int

(* sml-nj gives:
    stdIn:6.1-6.18 Warning: type vars not generalized because of
       value restriction are instantiated to dummy types (X1,X2,...)
 *)
Option.valOf NONE;
uncaught exception Option

val noneInt = if true then NONE else SOME 0;
val noneInt = NONE : int option

Sys.plan ();
val it =
  "apply(fnCode match(true, constant([NONE]), _, apply(fnValue tyCon, argCode constant(0))), argCode constant(true))"
  : string

Option.valOf noneInt;
uncaught exception Option

Sys.plan ();
val it = "apply(fnValue Option.valOf, argCode constant([NONE]))" : string


(*) val filter : ('a -> bool) -> 'a -> 'a option
Option.filter (fn x => x mod 2 = 0) 1;
val it = NONE : int option

Option.filter (fn x => x mod 2 = 0) 2;
val it = SOME 2 : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Option.filter, argCode match(x, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name x), constant(2))), constant(0))))), argCode constant(2))"
  : string


(*) val flatten : 'a option option -> 'a option
(*) (This function is called "Option.join" in the Standard ML basis library.)
Option.flatten (SOME (SOME 1));
val it = SOME 1 : int option

Option.flatten (SOME noneInt);
val it = NONE : int option

(* sml-nj gives
  stdIn:1.2-1.18 Warning: type vars not generalized because of
     value restriction are instantiated to dummy types (X1,X2,...)
*)
Option.flatten NONE;
val it = NONE : 'a option

Sys.plan ();
val it = "apply(fnValue Option.flatten, argCode constant([NONE]))" : string


(*) val app : ('a -> unit) -> 'a option -> unit
Option.app General.ignore (SOME 1);
val it = () : unit

Option.app General.ignore NONE;
val it = () : unit

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Option.app, argCode constant(General.ignore)), argCode constant([NONE]))"
  : string


(*) val map : ('a -> 'b) -> 'a option -> 'b option
Option.map String.size (SOME "xyz");
val it = SOME 3 : int option

Option.map String.size NONE;
val it = NONE : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Option.map, argCode constant(String.size)), argCode constant([NONE]))"
  : string


(*) val mapPartial : ('a -> 'b option) -> 'a option -> 'b option
Option.mapPartial (fn s => if s = "" then NONE else (SOME (String.size s))) (SOME "xyz");
val it = SOME 3 : int option

Option.mapPartial (fn s => if s = "" then NONE else (SOME (String.size s))) NONE;
val it = NONE : int option

Option.mapPartial (fn s => if s = "" then NONE else (SOME (String.size s))) (SOME "");
val it = NONE : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Option.mapPartial, argCode match(s, apply(fnCode match(true, constant([NONE]), _, apply(fnValue tyCon, argCode apply(fnValue String.size, argCode get(name s)))), argCode apply(fnValue =, argCode tuple(get(name s), constant()))))), argCode apply(fnValue tyCon, argCode constant()))"
  : string


(*) val compose : ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option
Option.compose (String.size,
                (fn s => if s = "" then NONE
                 else SOME (String.substring (s, 1, String.size s))))
               "";
val it = NONE : int option

Option.compose (String.size,
                (fn s => if s = "" then NONE
                 else SOME (String.substring (s, 0, String.size s))))
               "a";
val it = SOME 1 : int option

Option.compose (String.size,
                (fn s => if s = "" then NONE
                 else SOME (String.substring (s, 0, String.size s))))
               "";
val it = NONE : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Option.compose, argCode tuple(constant(String.size), match(s, apply(fnCode match(true, constant([NONE]), _, apply(fnValue tyCon, argCode apply(fnValue String.substring, argCode tuple(get(name s), constant(0), apply(fnValue String.size, argCode get(name s)))))), argCode apply(fnValue =, argCode tuple(get(name s), constant())))))), argCode constant())"
  : string


(*) val composePartial : ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option
Option.composePartial (fn i => if i = 0 then NONE else (SOME i),
                       fn s => if s = "" then NONE else SOME (String.size s))
                      "abc";
val it = SOME 3 : int option

Option.composePartial (fn i => if i = 0 then NONE else (SOME i),
                       fn s => if s = "" then NONE else SOME (String.size s))
                      "";
val it = NONE : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Option.composePartial, argCode tuple(match(i, apply(fnCode match(true, constant([NONE]), _, apply(fnValue tyCon, argCode get(name i))), argCode apply(fnValue =, argCode tuple(get(name i), constant(0))))), match(s, apply(fnCode match(true, constant([NONE]), _, apply(fnValue tyCon, argCode apply(fnValue String.size, argCode get(name s)))), argCode apply(fnValue =, argCode tuple(get(name s), constant())))))), argCode constant())"
  : string


(* Real -------------------------------------------------------- *)

(*) val posInf : real
Real.posInf;
val it = inf : real


(*) val negInf : real
Real.negInf;
val it = ~inf : real


(* Relational -------------------------------------------------- *)

Relational.count [1, 2, 3];
val it = 3 : int

Relational.count [];
val it = 0 : int

Relational.count [false];
val it = 1 : int

Sys.plan ();
val it = "apply(fnValue Relational.count, argCode tuple(constant(false)))"
  : string


Relational.exists [1, 2, 3];
val it = true : bool

Relational.exists [];
val it = false : bool

Relational.exists [false];
val it = true : bool

Sys.plan ();
val it = "apply(fnValue Relational.exists, argCode tuple(constant(false)))"
  : string


Relational.notExists [1, 2, 3];
val it = false : bool

Relational.notExists [];
val it = true : bool

Relational.notExists [false];
val it = false : bool

Sys.plan ();
val it = "apply(fnValue Relational.notExists, argCode tuple(constant(false)))"
  : string


val emp = [
  {empno=7839, ename="KING", mgr=0},
  {empno=7566, ename="JONES", mgr=7839},
  {empno=7698, ename="BLAKE", mgr=7839},
  {empno=7782, ename="CLARK", mgr=7839},
  {empno=7788, ename="SCOTT", mgr=7566},
  {empno=7902, ename="FORD", mgr=7566},
  {empno=7499, ename="ALLEN", mgr=7698},
  {empno=7521, ename="WARD", mgr=7698},
  {empno=7654, ename="MARTIN", mgr=7698},
  {empno=7844, ename="TURNER", mgr=7698},
  {empno=7900, ename="JAMES", mgr=7698},
  {empno=7934, ename="MILLER", mgr=7782},
  {empno=7876, ename="ADAMS", mgr=7788},
  {empno=7369, ename="SMITH", mgr=7902}];
val emp =
  [{empno=7839,ename="KING",mgr=0},{empno=7566,ename="JONES",mgr=7839},
   {empno=7698,ename="BLAKE",mgr=7839},{empno=7782,ename="CLARK",mgr=7839},
   {empno=7788,ename="SCOTT",mgr=7566},{empno=7902,ename="FORD",mgr=7566},
   {empno=7499,ename="ALLEN",mgr=7698},{empno=7521,ename="WARD",mgr=7698},
   {empno=7654,ename="MARTIN",mgr=7698},{empno=7844,ename="TURNER",mgr=7698},
   {empno=7900,ename="JAMES",mgr=7698},{empno=7934,ename="MILLER",mgr=7782},
   ...] : {empno:int, ename:string, mgr:int} list

Relational.iterate
  (from e in emp where e.mgr = 0)
  fn (oldList, newList) =>
      (from d in newList,
          e in emp
      where e.mgr = d.empno
      yield e);
val it =
  [{empno=7839,ename="KING",mgr=0},{empno=7566,ename="JONES",mgr=7839},
   {empno=7698,ename="BLAKE",mgr=7839},{empno=7782,ename="CLARK",mgr=7839},
   {empno=7788,ename="SCOTT",mgr=7566},{empno=7902,ename="FORD",mgr=7566},
   {empno=7499,ename="ALLEN",mgr=7698},{empno=7521,ename="WARD",mgr=7698},
   {empno=7654,ename="MARTIN",mgr=7698},{empno=7844,ename="TURNER",mgr=7698},
   {empno=7900,ename="JAMES",mgr=7698},{empno=7934,ename="MILLER",mgr=7782},
   ...] : {empno:int, ename:string, mgr:int} list

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Relational.iterate, argCode from(sink join(op join, pat e_1, exp constant([[7839, KING, 0], [7566, JONES, 7839], [7698, BLAKE, 7839], [7782, CLARK, 7839], [7788, SCOTT, 7566], [7902, FORD, 7566], [7499, ALLEN, 7698], [7521, WARD, 7698], [7654, MARTIN, 7698], [7844, TURNER, 7698], [7900, JAMES, 7698], [7934, MILLER, 7782], [7876, ADAMS, 7788], [7369, SMITH, 7902]]), sink where(condition apply(fnValue =, argCode tuple(apply(fnValue nth:2, argCode get(name e)), constant(0))), sink collect(get(name e)))))), argCode match(v0, apply(fnCode match((oldList, newList), from(sink join(op join, pat d, exp get(name newList), sink join(op join, pat e, exp constant([[7839, KING, 0], [7566, JONES, 7839], [7698, BLAKE, 7839], [7782, CLARK, 7839], [7788, SCOTT, 7566], [7902, FORD, 7566], [7499, ALLEN, 7698], [7521, WARD, 7698], [7654, MARTIN, 7698], [7844, TURNER, 7698], [7900, JAMES, 7698], [7934, MILLER, 7782], [7876, ADAMS, 7788], [7369, SMITH, 7902]]), sink where(condition apply(fnValue =, argCode tuple(apply(fnValue nth:2, argCode get(name e)), apply(fnValue nth:0, argCode get(name d)))), sink collect(get(name e))))))), argCode get(name v0))))"
  : string


Relational.sum [1, 2, 3];
val it = 6 : int

Relational.sum [1.0, 2.5, 3.5];
val it = 7.0 : real

Sys.plan ();
val it =
  "apply(fnValue Relational.sum$real, argCode tuple(constant(1.0), constant(2.5), constant(3.5)))"
  : string


Relational.max [1, 2, 3];
val it = 3 : int

Relational.max [1.0, 2.5, 3.5];
val it = 3.5 : real

Relational.max ["a", "bc", "ab"];
val it = "bc" : string

Relational.max [false, true];
val it = true : bool

Sys.plan ();
val it =
  "apply(fnValue Relational.max, argCode tuple(constant(false), constant(true)))"
  : string


Relational.min [1, 2, 3];
val it = 1 : int

Relational.min [1.0, 2.5, 3.5];
val it = 1.0 : real

Relational.min ["a", "bc", "ab"];
val it = "a" : string

Relational.min [false, true];
val it = false : bool

Sys.plan ();
val it =
  "apply(fnValue Relational.min, argCode tuple(constant(false), constant(true)))"
  : string


Relational.only [2];
val it = 2 : int

Relational.only [1, 2, 3];
uncaught exception Size

Relational.only [];
uncaught exception Empty

Sys.plan ();
val it = "apply(fnValue Relational.only, argCode tuple)" : string


[1, 2] union [3] union [] union [4, 2, 5];
val it = [1,2,3,4,2,5] : int list

[] union [];
val it = [] : 'a list

Sys.plan ();
val it = "apply(fnValue union, argCode tuple(tuple, tuple))" : string


[1, 2] except [2] except [3] except [];
val it = [1] : int list

[] except [];
val it = [] : 'a list

["a"] except ["a"];
val it = [] : string list

["a", "b", "c", "a"] except ["a"];
val it = ["b","c"] : string list

["a", "b", "c", "a"] except ["c", "b", "c"];
val it = ["a","a"] : string list

["a", "b"] except ["a", "c"] except ["a"];
val it = ["b"] : string list

Sys.plan ();
val it =
  "apply(fnValue except, argCode tuple(apply(fnValue except, argCode tuple(tuple(constant(a), constant(b)), tuple(constant(a), constant(c)))), tuple(constant(a))))"
  : string


[1, 2] intersect [2] intersect [0, 2, 4];
val it = [2] : int list

[1, 2] intersect [];
val it = [] : int list

[] intersect [1, 2];
val it = [] : int list

["a", "b", "a"] intersect ["b", "a"];
val it = ["a","b","a"] : string list

[(1, 2), (2, 3)] intersect [(2, 4), (1, 2)];
val it = [(1,2)] : (int * int) list

[1, 2, 3] intersect [2, 3, 4] except [1, 3, 5];
val it = [2] : int list

[1, 2, 3] except [1, 3, 5] intersect [2, 3, 4];
val it = [1,2] : int list

Sys.plan ();
val it =
  "apply(fnValue except, argCode tuple(tuple(constant(1), constant(2), constant(3)), apply(fnValue intersect, argCode tuple(tuple(constant(1), constant(3), constant(5)), tuple(constant(2), constant(3), constant(4))))))"
  : string


1 elem [1, 2, 3];
val it = true : bool

1 elem [2, 3, 4];
val it = false : bool

1 elem [];
val it = false : bool

[] elem [[0], [1, 2]];
val it = false : bool

[] elem [[0], [], [1, 2]];
val it = true : bool

(1, 2) elem [(0, 1), (1, 2)];
val it = true : bool

(1, 2) elem [(0, 1), (2, 3)];
val it = false : bool

Sys.plan ();
val it =
  "apply(fnValue elem, argCode tuple(tuple(constant(1), constant(2)), tuple(tuple(constant(0), constant(1)), tuple(constant(2), constant(3)))))"
  : string


1 notElem [1, 2, 3];
val it = false : bool

1 notElem [2, 3, 4];
val it = true : bool

1 notElem [];
val it = true : bool

[] notElem [[0], [1, 2]];
val it = true : bool

[] notElem [[0], [], [1, 2]];
val it = false : bool

(1, 2) notElem [(0, 1), (1, 2)];
val it = false : bool

(1, 2) notElem [(0, 1), (2, 3)];
val it = true : bool

Sys.plan ();
val it =
  "apply(fnValue notElem, argCode tuple(tuple(constant(1), constant(2)), tuple(tuple(constant(0), constant(1)), tuple(constant(2), constant(3)))))"
  : string


(* Sys --------------------------------------------------------- *)

(*) val env : unit -> string list
Sys.env;
val it = fn : unit -> (string * string) list

Sys.env ();
val it =
  [("EQUAL","order"),("GREATER","order"),
   ("General",
   "{ignore:forall 'a. 'a -> unit, op o:forall 'a 'b 'c. ('b -> 'c) * ('a -> 'b) -> 'a -> 'c}"),
   ("Interact","{use:string -> unit}"),("LESS","order"),
   ("List",
   "{all:forall 'a. ('a -> bool) -> 'a list -> bool, app:forall 'a. ('a -> unit) -> 'a list -> unit, at:forall 'a. 'a list * 'a list -> 'a list, collate:forall 'a. ('a * 'a -> order) -> 'a list * 'a list -> order, concat:forall 'a. 'a list list -> 'a list, drop:forall 'a. 'a list * int -> 'a list, exists:forall 'a. ('a -> bool) -> 'a list -> bool, filter:forall 'a. ('a -> bool) -> 'a list -> 'a list, find:forall 'a. ('a -> bool) -> 'a list -> 'a option, foldl:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b, foldr:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b, getItem:forall 'a. 'a list -> ('a * 'a list) option, hd:forall 'a. 'a list -> 'a, last:forall 'a. 'a list -> 'a, length:forall 'a. 'a list -> int, map:forall 'a 'b. ('a -> 'b) -> 'a list -> 'b list, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a list -> 'b list, nil:forall 'a. 'a list, nth:forall 'a. 'a list * int -> 'a, null:forall 'a. 'a list -> bool, op @:forall 'a. 'a list * 'a list -> 'a list, partition:forall 'a. ('a -> bool) -> 'a list -> 'a list * 'a list, rev:forall 'a. 'a list -> 'a list, revAppend:forall 'a. 'a list * 'a list -> 'a list, tabulate:forall 'a. int * (int -> 'a) -> 'a list, take:forall 'a. 'a list * int -> 'a list, tl:forall 'a. 'a list -> 'a list}"),
   ("Math",
   "{acos:real -> real, asin:real -> real, atan:real -> real, atan2:real * real -> real, cos:real -> real, cosh:real -> real, e:real, exp:real -> real, ln:real -> real, log10:real -> real, pi:real, pow:real * real -> real, sin:real -> real, sinh:real -> real, sqrt:real -> real, tan:real -> real, tanh:real -> real}"),
   ("NONE","'a option"),
   ("Option",
   "{app:forall 'a. ('a option -> unit) -> 'a option -> unit, compose:forall 'a 'b 'c. ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option, composePartial:forall 'a 'b 'c. ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option, filter:forall 'a. ('a -> bool) -> 'a -> 'a option, flatten:forall 'a. 'a option option -> 'a option, getOpt:forall 'a. 'a option * 'a -> 'a, isSome:forall 'a. 'a option -> bool, map:forall 'a 'b. ('a -> 'b) -> 'a option -> 'b option, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a option -> 'b option, valOf:forall 'a. 'a option -> 'a}"),
   ("Real","{negInf:real, posInf:real}"),
   ("Relational",
   "{count:forall 'a. 'a list -> int, exists:forall 'a. 'a list -> bool, iterate:forall 'a. 'a list -> ('a list * 'a list -> 'a list) -> 'a list, max:forall 'a. 'a list -> 'a, min:forall 'a. 'a list -> 'a, notExists:forall 'a. 'a list -> bool, only:forall 'a. 'a list -> 'a, sum:forall 'a. 'a list -> 'a}"),
   ("SOME","forall 'a. 'a -> 'a option"),...] : (string * string) list


env;
val it = fn : unit -> (string * string) list

env ();
val it =
  [("EQUAL","order"),("GREATER","order"),
   ("General",
   "{ignore:forall 'a. 'a -> unit, op o:forall 'a 'b 'c. ('b -> 'c) * ('a -> 'b) -> 'a -> 'c}"),
   ("Interact","{use:string -> unit}"),("LESS","order"),
   ("List",
   "{all:forall 'a. ('a -> bool) -> 'a list -> bool, app:forall 'a. ('a -> unit) -> 'a list -> unit, at:forall 'a. 'a list * 'a list -> 'a list, collate:forall 'a. ('a * 'a -> order) -> 'a list * 'a list -> order, concat:forall 'a. 'a list list -> 'a list, drop:forall 'a. 'a list * int -> 'a list, exists:forall 'a. ('a -> bool) -> 'a list -> bool, filter:forall 'a. ('a -> bool) -> 'a list -> 'a list, find:forall 'a. ('a -> bool) -> 'a list -> 'a option, foldl:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b, foldr:forall 'a 'b. ('a * 'b -> 'b) -> 'b -> 'a list -> 'b, getItem:forall 'a. 'a list -> ('a * 'a list) option, hd:forall 'a. 'a list -> 'a, last:forall 'a. 'a list -> 'a, length:forall 'a. 'a list -> int, map:forall 'a 'b. ('a -> 'b) -> 'a list -> 'b list, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a list -> 'b list, nil:forall 'a. 'a list, nth:forall 'a. 'a list * int -> 'a, null:forall 'a. 'a list -> bool, op @:forall 'a. 'a list * 'a list -> 'a list, partition:forall 'a. ('a -> bool) -> 'a list -> 'a list * 'a list, rev:forall 'a. 'a list -> 'a list, revAppend:forall 'a. 'a list * 'a list -> 'a list, tabulate:forall 'a. int * (int -> 'a) -> 'a list, take:forall 'a. 'a list * int -> 'a list, tl:forall 'a. 'a list -> 'a list}"),
   ("Math",
   "{acos:real -> real, asin:real -> real, atan:real -> real, atan2:real * real -> real, cos:real -> real, cosh:real -> real, e:real, exp:real -> real, ln:real -> real, log10:real -> real, pi:real, pow:real * real -> real, sin:real -> real, sinh:real -> real, sqrt:real -> real, tan:real -> real, tanh:real -> real}"),
   ("NONE","'a option"),
   ("Option",
   "{app:forall 'a. ('a option -> unit) -> 'a option -> unit, compose:forall 'a 'b 'c. ('a -> 'b) * ('c -> 'a option) -> 'c -> 'b option, composePartial:forall 'a 'b 'c. ('a -> 'b option) * ('c -> 'a option) -> 'c -> 'b option, filter:forall 'a. ('a -> bool) -> 'a -> 'a option, flatten:forall 'a. 'a option option -> 'a option, getOpt:forall 'a. 'a option * 'a -> 'a, isSome:forall 'a. 'a option -> bool, map:forall 'a 'b. ('a -> 'b) -> 'a option -> 'b option, mapPartial:forall 'a 'b. ('a -> 'b option) -> 'a option -> 'b option, valOf:forall 'a. 'a option -> 'a}"),
   ("Real","{negInf:real, posInf:real}"),
   ("Relational",
   "{count:forall 'a. 'a list -> int, exists:forall 'a. 'a list -> bool, iterate:forall 'a. 'a list -> ('a list * 'a list -> 'a list) -> 'a list, max:forall 'a. 'a list -> 'a, min:forall 'a. 'a list -> 'a, notExists:forall 'a. 'a list -> bool, only:forall 'a. 'a list -> 'a, sum:forall 'a. 'a list -> 'a}"),
   ("SOME","forall 'a. 'a -> 'a option"),...] : (string * string) list


(*) val plan : unit -> string
Sys.plan;
val it = fn : unit -> string

1 + 2;
val it = 3 : int

Sys.plan ();
val it = "apply(fnValue +, argCode tuple(constant(1), constant(2)))" : string


(*) val set : string * 'a -> unit
Sys.set;
val it = fn : string * 'a -> unit

Sys.set ("hybrid", false);
val it = () : unit

Sys.plan ();
val it =
  "apply(fnValue Sys.set, argCode tuple(constant(hybrid), constant(false)))"
  : string


(*) val show : string -> string option
Sys.show;
val it = fn : string -> string option

Sys.show "hybrid";
val it = SOME "false" : string option

Sys.set ("hybrid", true);
val it = () : unit

Sys.show "hybrid";
val it = SOME "true" : string option

Sys.show "optionalInt";
val it = NONE : string option

Sys.plan ();
val it = "apply(fnValue Sys.show, argCode constant(optionalInt))" : string


Sys.set ("optionalInt", ~5);
val it = () : unit

Sys.show "optionalInt";
val it = SOME "-5" : string option


(*) val unset : string -> unit
Sys.unset;
val it = fn : string -> unit

Sys.unset "hybrid";
val it = () : unit

Sys.unset "optionalInt";
val it = () : unit

Sys.plan ();
val it = "apply(fnValue Sys.unset, argCode constant(optionalInt))" : string


(* Vector ------------------------------------------------------ *)

(*) Vector.fromList : 'a list -> 'a vector
Vector.fromList;
val it = fn : 'a list -> 'a vector

Vector.fromList [1,2];
val it = #[1,2] : int vector

Sys.plan ();
val it =
  "apply(fnValue Vector.fromList, argCode tuple(constant(1), constant(2)))"
  : string


(* supported in sml-nj but not morel:
 #[1,2];
 *)

(* sml-nj says:
  stdIn:3.1-3.19 Warning: type vars not generalized because of
     value restriction are instantiated to dummy types (X1,X2,...)
  val it = #[] : ?.X1 vector
*)
Vector.fromList [];
val it = #[] : 'a vector

Sys.plan ();
val it = "apply(fnValue Vector.fromList, argCode tuple)" : string


(*) Vector.maxLen: int
Vector.maxLen;
val it = 16777215 : int

Sys.plan ();
val it = "constant(16777215)" : string


(*) Vector.tabulate : int * (int -> 'a) -> 'a vector
Vector.tabulate;
val it = fn : int * (int -> 'a) -> 'a vector

Vector.tabulate (5, let fun fact n = if n = 0 then 1 else n * fact (n - 1) in fact end);
val it = #[1,1,2,6,24] : int vector

Sys.plan ();
val it =
  "apply(fnValue Vector.tabulate, argCode tuple(constant(5), let1(matchCode match(fact, match(n, apply(fnCode match(true, constant(1), _, apply(fnValue *, argCode tuple(get(name n), apply(fnCode link, argCode apply(fnValue -, argCode tuple(get(name n), constant(1))))))), argCode apply(fnValue =, argCode tuple(get(name n), constant(0)))))), resultCode get(name fact))))"
  : string


(*) Vector.length : 'a vector -> int
Vector.length;
val it = fn : 'a vector -> int

Vector.length (Vector.fromList [1,2,3]);
val it = 3 : int

Sys.plan ();
val it =
  "apply(fnValue Vector.length, argCode apply(fnValue Vector.fromList, argCode tuple(constant(1), constant(2), constant(3))))"
  : string


(*) Vector.sub : 'a vector * int -> 'a
Vector.sub;
val it = fn : 'a vector * int -> 'a

Vector.sub (Vector.fromList [3,6,9], 2);
val it = 9 : int

Vector.sub (Vector.fromList [3,6,9], ~1);
uncaught exception Subscript [subscript out of bounds]

Vector.sub (Vector.fromList [3,6,9], 3);
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue Vector.sub, argCode tuple(apply(fnValue Vector.fromList, argCode tuple(constant(3), constant(6), constant(9))), constant(3)))"
  : string


(*) Vector.update : 'a vector * int * 'a -> 'a vector
Vector.update;
val it = fn : 'a vector * int * 'a -> 'a vector

Vector.update (Vector.fromList ["a","b","c"], 1, "baz");
val it = #["a","baz","c"] : string vector

Vector.update (Vector.fromList ["a","b","c"], ~1, "baz");
uncaught exception Subscript [subscript out of bounds]

Vector.update (Vector.fromList ["a","b","c"], 3, "baz");
uncaught exception Subscript [subscript out of bounds]

Sys.plan ();
val it =
  "apply(fnValue Vector.update, argCode tuple(apply(fnValue Vector.fromList, argCode tuple(constant(a), constant(b), constant(c))), constant(3), constant(baz)))"
  : string


(*) Vector.concat : 'a vector list -> 'a vector
Vector.concat;
val it = fn : 'a vector list -> 'a vector

Vector.concat [Vector.fromList ["a","b"],
  Vector.fromList [], Vector.fromList ["c"]];
val it = #["a","b","c"] : string vector

Sys.plan ();
val it =
  "apply(fnValue Vector.concat, argCode tuple(apply(fnValue Vector.fromList, argCode tuple(constant(a), constant(b))), apply(fnValue Vector.fromList, argCode tuple), apply(fnValue Vector.fromList, argCode tuple(constant(c)))))"
  : string


(*) Vector.appi : (int * 'a -> unit) -> 'a vector -> unit
Vector.appi;
val it = fn : (int * 'a -> unit) -> 'a vector -> unit

Vector.appi (fn (i,s) => ignore s) (Vector.fromList ["a", "b", "c"]);
val it = () : unit

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.appi, argCode match(v0, apply(fnCode match((i, s), apply(fnValue General.ignore, argCode get(name s))), argCode get(name v0)))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(a), constant(b), constant(c))))"
  : string


(*) Vector.app  : ('a -> unit) -> 'a vector -> unit
Vector.app;
val it = fn : ('a -> unit) -> 'a vector -> unit

Vector.app (fn s => ignore s) (Vector.fromList ["a", "b", "c"]);
val it = () : unit

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.app, argCode match(s, apply(fnValue General.ignore, argCode get(name s)))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(a), constant(b), constant(c))))"
  : string


(*) Vector.mapi : (int * 'a -> 'b) -> 'a vector -> 'b vector
Vector.mapi;
val it = fn : (int * 'a -> 'b) -> 'a vector -> 'b vector

Vector.mapi (fn (i, s) => String.sub (s, i)) (Vector.fromList ["abc", "xyz"]);
val it = #[#"a",#"y"] : char vector

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.mapi, argCode match(v0, apply(fnCode match((i, s), apply(fnValue String.sub, argCode tuple(get(name s), get(name i)))), argCode get(name v0)))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(abc), constant(xyz))))"
  : string


(*) Vector.map  : ('a -> 'b) -> 'a vector -> 'b vector
Vector.map;
val it = fn : ('a -> 'b) -> 'a vector -> 'b vector

Vector.map (fn s => String.sub (s, 0)) (Vector.fromList ["abc", "xyz"]);
val it = #[#"a",#"x"] : char vector

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.map, argCode match(s, apply(fnValue String.sub, argCode tuple(get(name s), constant(0))))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(abc), constant(xyz))))"
  : string


(*) Vector.foldli : (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldli;
val it = fn : (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b

Vector.foldli (fn (i,j,a) => a + i * j) 0 (Vector.fromList [2,3,4]);
val it = 11 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnCode apply(fnValue Vector.foldli, argCode match(v0, apply(fnCode match((i, j, a), apply(fnValue +, argCode tuple(get(name a), apply(fnValue *, argCode tuple(get(name i), get(name j)))))), argCode get(name v0)))), argCode constant(0)), argCode apply(fnValue Vector.fromList, argCode tuple(constant(2), constant(3), constant(4))))"
  : string


(*) Vector.foldri : (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldri;
val it = fn : (int * 'a * 'b -> 'b) -> 'b -> 'a vector -> 'b

Vector.foldri (fn (i,j,a) => a + i * j) 0 (Vector.fromList [2,3,4]);
val it = 11 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnCode apply(fnValue Vector.foldri, argCode match(v0, apply(fnCode match((i, j, a), apply(fnValue +, argCode tuple(get(name a), apply(fnValue *, argCode tuple(get(name i), get(name j)))))), argCode get(name v0)))), argCode constant(0)), argCode apply(fnValue Vector.fromList, argCode tuple(constant(2), constant(3), constant(4))))"
  : string


(*) Vector.foldl  : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldl;
val it = fn : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b

Vector.foldl (fn (j,a) => a + j) 0 (Vector.fromList [2,3,4]);
val it = 9 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnCode apply(fnValue Vector.foldl, argCode match(v0, apply(fnCode match((j, a), apply(fnValue +, argCode tuple(get(name a), get(name j)))), argCode get(name v0)))), argCode constant(0)), argCode apply(fnValue Vector.fromList, argCode tuple(constant(2), constant(3), constant(4))))"
  : string


(*) Vector.foldr  : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b
Vector.foldr;
val it = fn : ('a * 'b -> 'b) -> 'b -> 'a vector -> 'b

Vector.foldr (fn (j,a) => a + j) 0 (Vector.fromList [2,3,4]);
val it = 9 : int

Sys.plan ();
val it =
  "apply(fnCode apply(fnCode apply(fnValue Vector.foldr, argCode match(v0, apply(fnCode match((j, a), apply(fnValue +, argCode tuple(get(name a), get(name j)))), argCode get(name v0)))), argCode constant(0)), argCode apply(fnValue Vector.fromList, argCode tuple(constant(2), constant(3), constant(4))))"
  : string


(*) Vector.findi : (int * 'a -> bool) -> 'a vector -> (int * 'a) option
Vector.findi;
val it = fn : (int * 'a -> bool) -> 'a vector -> (int * 'a) option

Vector.findi (fn (i,j) => j < i) (Vector.fromList [10,8,6,4,2]);
val it = SOME (4,2) : (int * int) option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.findi, argCode match(v0, apply(fnCode match((i, j), apply(fnValue <, argCode tuple(get(name j), get(name i)))), argCode get(name v0)))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(10), constant(8), constant(6), constant(4), constant(2))))"
  : string


(*) Vector.find  : ('a -> bool) -> 'a vector -> 'a option
Vector.find;
val it = fn : ('a -> bool) -> 'a vector -> 'a option

Vector.find (fn j => j mod 2 = 0) (Vector.fromList [3,5,7,8,9]);
val it = SOME 8 : int option

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.find, argCode match(j, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name j), constant(2))), constant(0))))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(3), constant(5), constant(7), constant(8), constant(9))))"
  : string


(*) Vector.exists : ('a -> bool) -> 'a vector -> bool
Vector.exists;
val it = fn : ('a -> bool) -> 'a vector -> bool

Vector.exists (fn j => j mod 2 = 0) (Vector.fromList [3,5,7,8,9]);
val it = true : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.exists, argCode match(j, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name j), constant(2))), constant(0))))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(3), constant(5), constant(7), constant(8), constant(9))))"
  : string


(*) Vector.all : ('a -> bool) -> 'a vector -> bool
Vector.all;
val it = fn : ('a -> bool) -> 'a vector -> bool

Vector.all (fn j => j mod 2 = 0) (Vector.fromList [3,5,7,8,9]);
val it = false : bool

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.all, argCode match(j, apply(fnValue =, argCode tuple(apply(fnValue mod, argCode tuple(get(name j), constant(2))), constant(0))))), argCode apply(fnValue Vector.fromList, argCode tuple(constant(3), constant(5), constant(7), constant(8), constant(9))))"
  : string


(*) Vector.collate : ('a * 'a -> order) -> 'a vector * 'a vector -> order
Vector.collate;
val it = fn : ('a * 'a -> order) -> 'a vector * 'a vector -> order

Vector.collate
  (fn (i,j) => if i < j then LESS else if i = j then EQUAL else GREATER)
  (Vector.fromList [1,3,5], Vector.fromList [1,3,6]);
val it = LESS : order

Sys.plan ();
val it =
  "apply(fnCode apply(fnValue Vector.collate, argCode match(v0, apply(fnCode match((i, j), apply(fnCode match(true, constant([LESS]), _, apply(fnCode match(true, constant([EQUAL]), _, constant([GREATER])), argCode apply(fnValue =, argCode tuple(get(name i), get(name j))))), argCode apply(fnValue <, argCode tuple(get(name i), get(name j))))), argCode get(name v0)))), argCode tuple(apply(fnValue Vector.fromList, argCode tuple(constant(1), constant(3), constant(5))), apply(fnValue Vector.fromList, argCode tuple(constant(1), constant(3), constant(6)))))"
  : string


(*) End builtIn.sml
