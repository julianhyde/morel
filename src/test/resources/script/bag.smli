(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *
 * Bags vs lists, and relational operators between the two
 *)
Sys.set ("lineWidth", 78);
> val it = () : unit
Sys.set ("printDepth", 6);
> val it = () : unit
Sys.set ("printLength", 64);
> val it = () : unit
Sys.set ("stringDepth", ~1);
> val it = () : unit

useSilently "scott.smli";
> [opening scott.smli]
> val it = () : unit

(*) constants
bag [1,2,3];
> val it = [1,2,3] : int bag
bag ([]: int list);
> val it = [] : int bag
bag [(1,true),(2,false)];
> val it = [(1,true),(2,false)] : (int * bool) bag
bag [[1],[2],[3]];
> val it = [[1],[2],[3]] : int list bag

(*) check that we get good error messages when we apply a list function to
(*) a bag, and vice versa
String.size 1;
> 0.0-0.0 Error: Cannot deduce type: conflict: int vs string
>   raised at: 0.0-0.0
List.length List.nil;
> val it = 0 : int
Bag.length Bag.nil;
> val it = 0 : int
List.length Bag.nil;
> val it = 0 : int
Bag.length List.nil;
> val it = 0 : int

(*) assign to variables
val intList = [1,2,3];
> val intList = [1,2,3] : int list
val intBag = bag intList;
> val intBag = [1,2,3] : int bag
val emptyIntBag = bag ([]: int list);
> val emptyIntBag = [] : int bag
val pairList = [(1,true),(2,false)];
> val pairList = [(1,true),(2,false)] : (int * bool) list
val pairBag = bag pairList;
> val pairBag = [(1,true),(2,false)] : (int * bool) bag
val recList = [{i=1,b=true}, {i=2,b=false}, {i=1,b=false}];
> val recList = [{b=true,i=1},{b=false,i=2},{b=false,i=1}]
>   : {b:bool, i:int} list
val recBag = bag recList;
> val recBag = [{b=true,i=1},{b=false,i=2},{b=false,i=1}] : {b:bool, i:int} bag

(*) empty 'from' is ordered
from;
> val it = [()] : unit list

(*) scan if ordered if the expression is
from i in intList;
> val it = [1,2,3] : int list
from i in intBag;
> val it = [1,2,3] : int bag

(*) where preserves collection type
from i in intList where i > 1;
> val it = [2,3] : int list
from i in intBag where i > 1;
> val it = [2,3] : int bag

(*) group's output is unordered
from i in intList group;
> val it = [()] : unit bag
from i in intBag group;
> val it = [()] : unit bag
from i in intList group i;
> val it = [1,2,3] : int bag
from i in intBag group i;
> val it = [1,2,3] : int bag
from r in recList group r.i;
> val it = [1,2] : int bag
from r in recBag group r.i;
> val it = [1,2] : int bag

(*) the input to an aggregate functions is a bag, even if the input
(*) stream is a list. (We need to devise syntax for aggregate functions
(*) to sort their input.)
from r in recList group r.i compute count;
> val it = [{count=2,i=1},{count=1,i=2}] : {count:int, i:int} bag
from r in recBag group r.i compute count;
> val it = [{count=2,i=1},{count=1,i=2}] : {count:int, i:int} bag
from r in recList group r.i compute bs = (fn x => x) of r.b;
> val it = [{bs=[true,false],i=1},{bs=[false],i=2}] : {bs:bool bag, i:int} bag
from r in recBag group r.i compute bs = (fn x => x) of r.b;
> val it = [{bs=[true,false],i=1},{bs=[false],i=2}] : {bs:bool bag, i:int} bag

(*) distinct output is unordered
from i in intList distinct;
> val it = [1,2,3] : int bag
from i in intBag distinct;
> val it = [1,2,3] : int bag

(*) order's output is ordered
from i in intList order i;
> val it = [1,2,3] : int list
from i in intBag order i;
> val it = [1,2,3] : int list
from i in intList order ();
> val it = [1,2,3] : int list
from i in intBag order ();
> val it = [1,2,3] : int list
from r in recList group r.i compute bs = (fn x => x) of r.b order i desc;
> val it = [{bs=[false],i=2},{bs=[true,false],i=1}] : {bs:bool bag, i:int} list
from r in recBag group r.i compute bs = (fn x => x) of r.b order i desc;
> val it = [{bs=[false],i=2},{bs=[true,false],i=1}] : {bs:bool bag, i:int} list

(*) join preserves collection type (should it?)

(*) yield preserves collection type
from i in intList yield {j=i*i, i};
> val it = [{i=1,j=1},{i=2,j=4},{i=3,j=9}] : {i:int, j:int} list
from i in intBag yield {j=i*i, i};
> val it = [{i=1,j=1},{i=2,j=4},{i=3,j=9}] : {i:int, j:int} bag

(*) into preserves collection type

(*) into allows both 'bag' and 'list' functions

(*) through preserves collection type

(*) through allows both 'bag' and 'list' functions

(*) elem works on both 'bag' and 'list' values

(*) notelem works on both 'bag' and 'list' values

(*) skip preserves collection type (but makes more sense for ordered)
from i in intList skip 1;
> val it = [2,3] : int list
from i in intBag skip 1;
> val it = [2,3] : int bag

(*) take preserves collection type (but makes more sense for ordered)
from i in intList take 2;
> val it = [1,2] : int list
from i in intBag take 2;
> val it = [1,2] : int bag
from i in intList skip 1 take 1;
> val it = [2] : int list
from i in intBag skip 1 take 1;
> val it = [2] : int bag

(*) dummy
from message in ["the end"];
> val it = ["the end"] : string list

(*) End bag.smli
