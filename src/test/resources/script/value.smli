(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *
 * Value structure tests - universal value representation for
 * embedded language interoperability
 *)
Sys.set ("printDepth", ~1);
> val it = () : unit
Sys.set ("lineWidth", 78);
> val it = () : unit
Sys.set ("stringDepth", ~1);
> val it = () : unit

(*) Test the value datatype constructors

(*) UNIT constructor
UNIT;
> val it = () : unit value

(*) BOOL constructor
BOOL true;
> val it = true : bool value
BOOL false;
> val it = false : bool value

(*) INT constructor
INT 0;
> val it = 0 : int value
INT 42;
> val it = 42 : int value
INT ~5;
> val it = ~5 : int value

(*) REAL constructor
REAL 0.0;
> val it = 0.0 : real value
REAL 3.14;
> val it = 3.14 : real value
REAL ~2.5;
> val it = ~2.5 : real value

(*) CHAR constructor
CHAR #"a";
> val it = #"a" : char value
CHAR #"Z";
> val it = #"Z" : char value
CHAR #"\n";
> val it = #"\n" : char value

(*) STRING constructor
STRING "";
> val it = "" : string value
STRING "hello";
> val it = "hello" : string value
STRING "hello\nworld";
> val it = "hello\nworld" : string value

(*) LIST constructor - empty list; element type is 'value' because it is empty
LIST [];
> val it = [] : value list value

(*) LIST constructor - list of ints; element type is 'int' because it is homogeneous
LIST [INT 1, INT 2, INT 3];
> val it = [1,2,3] : int list value

(*) LIST constructor - nested lists; element type is 'int list'
LIST [LIST [INT 1, INT 2], LIST [INT 3]];
> val it = [[1,2],[3]] : int list list value

(*) BAG constructor - empty bag
BAG [];
> val it = [] : value bag value

(*) BAG constructor - bag of ints
BAG [INT 1, INT 2, INT 3, INT 2];
> val it = [1,2,3,2] : int bag value

(*) VECTOR constructor - empty vector
VECTOR [];
> val it = #[] : value vector value

(*) VECTOR constructor - vector of strings
VECTOR [STRING "a", STRING "b", STRING "c"];
> val it = #["a","b","c"] : string vector value

(*) VECTOR constructor - vector of string lists
VECTOR [LIST [STRING "a"], LIST [STRING "b", STRING "c"]];
> val it = #[["a"],["b","c"]] : string list vector value

(*) VECTOR constructor - vector of string lists, one of them empty
(*) TODO: Type should be 'string list vector', notwithstanding the empty list
VECTOR [LIST [STRING "a"], LIST [], LIST [STRING "b", STRING "c"]];
> val it = #[["a"],[],["b","c"]] : value vector value

(*) VALUE_NONE constructor
VALUE_NONE;
> val it = NONE : value option value

(*) VALUE_SOME constructor - with INT
VALUE_SOME (INT 42);
> val it = SOME 42 : int option value

(*) VALUE_SOME constructor - with STRING
VALUE_SOME (STRING "hello");
> val it = SOME "hello" : string option value

(*) RECORD constructor - empty record
RECORD [];
> val it = () : unit value

(*) RECORD constructor
RECORD [("x", INT 1), ("y", BOOL true)];
> val it = {x=1,y=true} : {x:int, y:bool} value

(*) RECORD constructor - various types, fields not in alphabetical order
RECORD [("name", STRING "Alice"), ("age", INT 30), ("b", BOOL true), ("i", INT 42), ("pets", LIST [STRING "cat", STRING "dog"])];
> val it = {age=30,b=true,i=42,name="Alice",pets=["cat","dog"]}
>   : {age:int, b:bool, i:int, name:string, pets:string list} value

(*) CONSTANT constructor - nullary constructor
CONSTANT "LESS";
> val it = LESS : order value

(*) TODO: better error message
CONSTANT "missing";
> java.lang.IllegalArgumentException: Unknown constructor: missing

(*) CONSTRUCT constructor - unary constructor
CONSTRUCT ("SOME", INT 42);
> val it = SOME 42 : int option value

(*) CONSTRUCT constructor - constructor with tuple
(* The "$list" isn't pretty. It's because CONS belongs to an internal datatype. *)
CONSTRUCT ("CONS", RECORD [("1", INT 1), ("2", CONSTANT "NIL")]);
> val it = CONS (1,NIL) : (int * 'a $list) $list value

(*) List of homogeneous records
LIST [
  RECORD [("name", STRING "Alice"), ("age", INT 30)],
  RECORD [("name", STRING "Bob"), ("age", INT 25)]
];
> val it = [{age=30,name="Alice"},{age=25,name="Bob"}]
>   : {age:int, name:string} list value

(*) List of heterogeneous records
LIST [
  RECORD [("name", STRING "Alice"), ("age", INT 30)],
  RECORD [("name", STRING "Bob")]
];
> val it = [{age=30,name="Alice"},{name="Bob"}] : value list value

(*) List of heterogeneous records and values
LIST [
  RECORD [("name", STRING "Alice"), ("age", INT 30)],
  STRING "Bob",
  LIST [INT 1, STRING "Carol"]
];
> val it = [{age=30,name="Alice"},"Bob",[1,"Carol"]] : value list value

(*) Pattern matching on value
fun isUnit v =
  case v of
    UNIT => true
  | _ => false;
> val isUnit = fn : value -> bool

isUnit UNIT;
> val it = true : bool
isUnit (INT 42);
> val it = false : bool

(*) Pattern matching to extract values
fun getInt v =
  case v of
    INT i => SOME i
  | _ => NONE;
> val getInt = fn : value -> int option

getInt (INT 42);
> val it = SOME 42 : int option
getInt (STRING "hello");
> val it = NONE : int option

(*) Recursive function on value
fun valueDepth v =
  case v of
    UNIT => 0
  | BOOL _ => 0
  | INT _ => 0
  | REAL _ => 0
  | CHAR _ => 0
  | STRING _ => 0
  | LIST [] => 0
  | LIST (v::vs) => Int.max (1 + (valueDepth v), valueDepth (LIST vs))
  | BAG [] => 0
  | BAG (v::vs) => Int.max (1 + (valueDepth v), valueDepth (BAG vs))
  | VECTOR [] => 0
  | VECTOR (v::vs) => Int.max (1 + (valueDepth v), valueDepth (VECTOR vs))
  | VALUE_NONE => 0
  | VALUE_SOME v => 1 + valueDepth v
  | RECORD [] => 0
  | RECORD ((_, v)::rest) => Int.max (1 + (valueDepth v), valueDepth (RECORD rest))
  | CONSTANT _ => 0
  | CONSTRUCT (_, v) => 1 + valueDepth v;
> val valueDepth = fn : value -> int

valueDepth UNIT;
> val it = 0 : int
valueDepth (INT 42);
> val it = 0 : int
valueDepth (LIST [INT 1, INT 2]);
> val it = 1 : int
valueDepth (LIST [LIST [INT 1]]);
> val it = 2 : int
valueDepth (RECORD [("x", LIST [INT 1, INT 2])]);
> val it = 2 : int

(*) Round-trip tests: parse (print v) = v
fun testRoundTrip v =
  let
    val s = Value.print v
    val v2 = Value.parse s
  in
    v = v2
  end;
> val testRoundTrip = fn : value -> bool

(*) Test primitives round-trip
testRoundTrip UNIT;
> val it = true : bool
testRoundTrip (BOOL true);
> val it = true : bool
testRoundTrip (BOOL false);
> val it = true : bool
testRoundTrip (INT 0);
> val it = true : bool
testRoundTrip (INT 42);
> val it = true : bool
testRoundTrip (INT ~5);
> val it = true : bool
(*) REAL comparisons - note: real is not an equality type in Standard ML
(*) so we can't directly compare REAL values; skip these tests
(*testRoundTrip (REAL 0.0);*)
(*> val it = true : bool*)
(*testRoundTrip (REAL 3.14);*)
(*> val it = true : bool*)
testRoundTrip (CHAR #"a");
> val it = true : bool
testRoundTrip (CHAR #"\n");
> val it = true : bool
testRoundTrip (STRING "");
> val it = true : bool
testRoundTrip (STRING "hello");
> val it = true : bool
testRoundTrip (STRING "hello\nworld");
> val it = true : bool

(*) Test collections round-trip
testRoundTrip (LIST []);
> val it = true : bool
testRoundTrip (LIST [INT 1, INT 2, INT 3]);
> val it = true : bool
testRoundTrip (LIST [LIST [INT 1], LIST [INT 2]]);
> val it = true : bool
testRoundTrip (BAG [INT 1, INT 2]);
> val it = true : bool
testRoundTrip (VECTOR [STRING "a", STRING "b"]);
> val it = true : bool

(*) Test VALUE_NONE and VALUE_SOME round-trip
testRoundTrip VALUE_NONE;
> val it = true : bool
testRoundTrip (VALUE_SOME (INT 42));
> val it = true : bool

(*) Test record round-trip
testRoundTrip (RECORD []);
> val it = true : bool
testRoundTrip (RECORD [("x", INT 1), ("y", INT 2)]);
> val it = true : bool
testRoundTrip (RECORD [("name", STRING "Alice"), ("age", INT 30)]);
> val it = true : bool

(*) Test CONSTANT and CONSTRUCT round-trip
testRoundTrip (CONSTANT "NIL");
> val it = true : bool
testRoundTrip (CONSTRUCT ("SOME", INT 42));
> val it = true : bool

(*) Test complex nested structure round-trip
testRoundTrip
  (LIST [
    RECORD [("name", STRING "Alice"), ("age", INT 30)],
    RECORD [("name", STRING "Bob"), ("age", INT 25)]
  ]);
> val it = true : bool

(*) Test parsing negative integers and reals
Value.parse "~5";
> val it = ~5 : int value
Value.parse "~3.14";
> val it = ~3.14 : real value
Value.parse "~20e~6";
> val it = ~2.0E~5 : real value

(*) Test round-trip for negative integers
testRoundTrip (INT ~5);
> val it = true : bool
testRoundTrip (INT ~100);
> val it = true : bool

(*) Test deeply nested structure with list field in record in list in list
val deeplyNested =
  LIST [
    LIST [
      RECORD [
        ("name", STRING "Alice"),
        ("scores", LIST [INT 95, INT 87, INT 92]),
        ("active", BOOL true)
      ],
      RECORD [
        ("name", STRING "Bob"),
        ("scores", LIST [INT 88, INT 90]),
        ("active", BOOL false)
      ]
    ],
    LIST [
      RECORD [
        ("name", STRING "Charlie"),
        ("scores", LIST [INT 76, INT 82, INT 79, INT 85]),
        ("active", BOOL true)
      ]
    ]
  ];
> val deeplyNested =
>   [
>    [{active=true,name="Alice",scores=[95,87,92]},
>     {active=false,name="Bob",scores=[88,90]}],
>    [{active=true,name="Charlie",scores=[76,82,79,85]}]]
>   : {active:bool, name:string, scores:int list} list list value

(*) Test round-trip on deeply nested structure
testRoundTrip deeplyNested;
> val it = true : bool

(*) Test print on deeply nested structure (should preserve all nesting)
Value.print deeplyNested;
> val it =
>   "[[{active = true, name = \"Alice\", scores = [95, 87, 92]}, {active = false, name = \"Bob\", scores = [88, 90]}], [{active = true, name = \"Charlie\", scores = [76, 82, 79, 85]}]]"
>   : string

(*) Test prettyPrint on deeply nested structure
Value.prettyPrint deeplyNested;
> val it =
>   "[[{active = true, name = \"Alice\", scores = [95, 87, 92]}, {active = false, name = \"Bob\", scores = [88, 90]}], [{active = true, name = \"Charlie\", scores = [76, 82, 79, 85]}]]"
>   : string

(*) Parse the printed representation and verify it matches
Value.parse (Value.print deeplyNested) = deeplyNested;
> val it = true : bool

(*) Test accessing nested data after round-trip
let
  val printed = Value.print deeplyNested
  val parsed = Value.parse printed
in
  parsed = deeplyNested
end;
> val it = true : bool

(*) End value.smli
