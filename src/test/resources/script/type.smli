(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *)

(*) Record and tuple are equivalent.
{1 = "a", 2 = true};
> val it = ("a",true) : string * bool
("a", true);
> val it = ("a",true) : string * bool
("a", true) = {1 = "a", 2 = true};
> val it = true : bool
{1 = "a", 2 = true} = ("a", true);
> val it = true : bool
("a", true) = {2 = true, 1 = "a"};
> val it = true : bool
("a", true) = {2 = true, 1 = "b"};
> val it = false : bool
("a", false) = {1 = "a", 2 = true};
> val it = false : bool

(*) Empty record and empty tuple are equivalent, and of type 'unit'.
{};
> val it = () : unit
();
> val it = () : unit
{} = ();
> val it = true : bool
() = {};
> val it = true : bool

(*) Expressions with type annotations
1: int;
> val it = 1 : int
(2, true): int * bool;
> val it = (2,true) : int * bool
[]: int list;
> val it = [] : int list
(1: int) + (2: int);
> val it = 3 : int
1 + (2: int);
> val it = 3 : int
(1: int) + 2;
> val it = 3 : int
String.size "abc": int;
> val it = 3 : int
String.size ("abc": string);
> val it = 3 : int
String.size ("abc": string): int;
> val it = 3 : int

(*) Patterns with type annotations
val x: int = 1;
> val x = 1 : int
val y: bool = true;
> val y = true : bool
val p: int * bool = (1, true);
> val p = (1,true) : int * bool
val empty: int list = [];
> val empty = [] : int list

(*) Function declarations with type annotations
fun f (x: int, y) = x + y;
> val f = fn : int * int -> int
fun f (x, y: int) = x + y;
> val f = fn : int * int -> int
fun f3 (e: {name: string, deptno:int}) = e.deptno;
> val f3 = fn : {deptno:int, name:string} -> int
fun hello (name: string, code: int): string = "hello!";
> val hello = fn : string * int -> string
fun hello2 (name: string) (code : int): string = "hello!";
> val hello2 = fn : string -> int -> string
val hello3: string * int -> string =
  fn (name, code) => "hello!";
> val hello3 = fn : string * int -> string
fun l1 [] = 0 | l1 ((h: string) :: t) = 1 + (l1 t);
> val l1 = fn : string list -> int
fun l2 [] = 0 | l2 (h :: (t: bool list)) = 1 + (l2 t);
> val l2 = fn : bool list -> int
fun countOption (NONE: string option) = 0
  | countOption (SOME x) = 1;
> val countOption = fn : string option -> int
fun countOption0 (NONE) = 0
  | countOption0 (SOME x) = if x = "" then 1 else 2;
> val countOption0 = fn : string option -> int
fun countOption00 (SOME x) = 1
  | countOption00 (NONE: string option) = 0;
> val countOption00 = fn : string option -> int
fun countOption1 (NONE) = 0
  | countOption1 (SOME x) = if x then 1 else 2;
> val countOption1 = fn : bool option -> int
fun countOption2 NONE: int = 0
  | countOption2 (SOME x) = 1;
> val countOption2 = fn : 'a option -> int
fun firstOrSecond (e1 :: e2 :: rest): int = e2
  | firstOrSecond (e1 :: rest) = e1;
> 0.0-0.0 Warning: match nonexhaustive
>   raised at: 0.0-0.0
> val firstOrSecond = fn : int list -> int

(*
sml-nj gives the following error:
stdIn:1.6-2.32 Error: parameter or result constraints of clauses don't agree [tycon mismatch]
  this clause:      'Z option -> string list
  previous clauses:      'Z option -> int list
  in declaration:
    f = (fn NONE => nil: int list
          | SOME x => nil: string list)
*)
fun f NONE:int list = []
  | f (SOME x):string list = [];
> stdIn:11.5-12.32 Error: parameter or result constraints of clauses don't agree [tycon mismatch]
>   raised at: stdIn:11.5-12.32

(*) Function with unit arg
fun one () = 1;
> val one = fn : unit -> int
one ();
> val it = 1 : int
one {};
> val it = 1 : int
let
  fun one () = 1
in
  one ()
end;
> val it = 1 : int

(*) A function with a type that is tricky to unparse correctly:
(*)   'a list -> ('a * 'a list) option
fun g [] = NONE
  | g (h :: t) = SOME (h, t);
> val g = fn : 'a list -> ('a * 'a list) option

(*) Ditto:
(*)   'a list -> ('a * 'a list option) option
fun g [] = NONE
  | g (h :: t) = SOME (h, SOME t);
> val g = fn : 'a list -> ('a * 'a list option) option

(*) Ditto:
(*)   'a list -> ('a option * 'a list option) option
fun g [] = NONE
  | g (h :: t) = SOME (SOME h, SOME t);
> val g = fn : 'a list -> ('a option * 'a list option) option

(*) Pattern-match on record
fun f {a = c, b} = b + c;
> val f = fn : {a:int, b:int} -> int
f {a = 5, b = 6};
> val it = 11 : int

fun f2 {a = 1, b} = b * 2
  | f2 {a, b} = b * 3;
> val f2 = fn : {a:int, b:int} -> int
f2 {a = 1, b = 6};
> val it = 12 : int
f2 {a = 2, b = 6};
> val it = 18 : int

Sys.set ("matchCoverageEnabled", false);
> val it = () : unit
fun f3 {a = 1, b} = b * 2;
> val f3 = fn : {a:int, b:int} -> int
Sys.unset "matchCoverageEnabled";
> val it = () : unit
f3 {a = 1, b = 6};
> val it = 12 : int

(*) The following correctly throws
(*)   unbound variable or constructor: a
(*) Disabled because error stacks made tests brittle.
(*) fun f4 {a = 1, b} = a + b;

(*) Variable with polymorphic type
val x = map;
> val x = fn : ('a -> 'b) -> 'a list -> 'b list
x explode ["ab", "c"];
> val it = [[#"a",#"b"],[#"c"]] : char list list

(*) Has polymorphic type
val rec len = fn x =>
    case x of head :: tail => 1 + (len tail)
            | [] => 0;
> val len = fn : 'a list -> int

len [];
> val it = 0 : int
len [1];
> val it = 1 : int
len [1,2];
> val it = 2 : int

map len (map explode ["ab", "", "cde"]);
> val it = [2,0,3] : int list
map (fn s => len (explode s)) ["ab", "", "cde"];
> val it = [2,0,3] : int list

(*) Type resolution involving record selectors
val emps =
  [{id = 100, name = "Fred", deptno = 10},
   {id = 101, name = "Velma", deptno = 20},
   {id = 102, name = "Shaggy", deptno = 30},
   {id = 103, name = "Scooby", deptno = 30}];
> val emps =
>   [{deptno=10,id=100,name="Fred"},{deptno=20,id=101,name="Velma"},
>    {deptno=30,id=102,name="Shaggy"},{deptno=30,id=103,name="Scooby"}]
>   : {deptno:int, id:int, name:string} list
map #deptno emps;
> val it = [10,20,30,30] : int list
map #deptno (List.filter (fn e => #deptno e > 10) emps);
> val it = [20,30,30] : int list
map #2 [(1,2),(3,1)];
> val it = [2,1] : int list
List.filter #1 [(true,1),(false,2),(true,3)];
> val it = [(true,1),(true,3)] : (bool * int) list
map #2 (List.filter #1 [(true,1),(false,2),(true,3)]);
> val it = [1,3] : int list

(*) Should give
(*)  Error: duplicate variable in pattern(s): e
(*
fun in_ e [] = false
  | in_ e e :: tl = true
  | in_ e hd :: tl = in_ e tl
*)

(*) Should give
(*) Error: operator and operand don't agree [tycon mismatch]
(*)     operator domain: 'Z list list
(*)     operand:         (({id:'X; 'Y} -> 'X) * ([+ ty] * [+ ty] -> [+ ty])) list
(*)     in expression:
(*)       aggregate (((fn <pat> => <exp>),sum) :: nil)
(*
let
  fun foldl f start [] = start
    | foldl f start (hd :: tl) = foldl f (f (start, hd)) tl;
  fun map f [] = []
    | map f (hd :: tl) = (f hd) :: (map f tl);
  fun computeAgg (extractor, folder) list =
      foldl folder (map extractor list);
  fun aggregate aggFns list =
      map (computeAgg list) aggFns;
  fun sum (x, y) = x + y;
in
  aggregate [(#id, sum)] emps
end;
*)

(*) Lambda applied to datatype
fn LESS => ~1
 | EQUAL => 0
 | GREATER => 1;
> val it = fn : order -> int

(*) Lambda with record argument
fn {a, b} => if b then a else a + 1;
> val it = fn : {a:int, b:bool} -> int

(*) Record containing polymorphic functions:
(*)  val it = {a=fn,b=fn}
(*) : {a:'a list -> ('a * 'a list) option, b:'b list -> ('b * 'b list) option}
{a = fn x => case x of [] => NONE | (h :: t) => SOME (h, t),
 b = fn x => case x of [] => NONE | (h :: t) => SOME (h, t)};
> val it = {a=fn,b=fn}
>   : {a:'a list -> ('a * 'a list) option, b:'b list -> ('b * 'b list) option}

(*) Similar, expressed via 'fun'.
(* sml/nj gives:
stdIn:1.2-1.66 Warning: type vars not generalized because of
   value restriction are instantiated to dummy types (X1,X2,...)
val it = {a=1,b=fn} : {a:int, b:?.X1 list -> (?.X1 * ?.X1 list) option}
*)
let
  fun g [] = NONE
    | g (h :: t) = SOME (h, t)
in
  {a=1, b=g}
end;
> val it = {a=1,b=fn} : {a:int, b:'a list -> ('a * 'a list) option}

(*) as above
{a = 1, b = let fun g [] = NONE | g (h :: t) = SOME (h, t) in g end};
> val it = {a=1,b=fn} : {a:int, b:'a list -> ('a * 'a list) option}

(*) List of monotype
[SOME true, NONE];
> val it = [SOME true,NONE] : bool option list
[SOME [1, 2], NONE];
> val it = [SOME [1,2],NONE] : int list option list
[NONE, SOME [{a=1,b=true}], NONE];
> val it = [NONE,SOME [{a=1,b=true}],NONE] : {a:int, b:bool} list option list
from b in [SOME true, NONE];
> val it = [SOME true,NONE] : bool option list

(*) If a function type is spread over several lines, put '->' at the start of
(*) the next line.
val f : ('a -> (int * int) list) -> ('a -> (int * int) list) -> 'a -> (int * int) list = fn a => fn b => fn c => [];
> val f = fn
>   : ('a -> (int * int) list)
>     -> ('b -> (int * int) list) -> 'c -> (int * int) list

(* SML/NJ output for previous is as follows. TODO match SML/NJ type variables.
> val f = fn
>   : ('a -> (int * int) list)
>     -> ('a -> (int * int) list) -> 'a -> (int * int) list
*)

(*) Function with tuple type and lots of type variables returns record type.
(*) Note that after 'z, type variables are 'ba, 'bb, etc.
(*) Also note that 'o' needs to be quoted.
fun r0 (a, b, c, d, e, f, g, h, i, j, k, l, m, n, `o`, p, q, r, s, t, u, v, w, x, y, z, aa, ab, ac) = {a=a,b=b,c=c};
> val r0 = fn
>   :
>     'a * 'b * 'c * 'd * 'e * 'f * 'g * 'h * 'i * 'j * 'k * 'l * 'm * 'n * 'o *
>     'p * 'q * 'r * 's * 't * 'u * 'v * 'w * 'x * 'y * 'z * 'ba * 'bb * 'bc
>     -> {a:'a, b:'b, c:'c}

(*) Highly curried function with lots of type variables returns record type.
fun r0 a b c d e f g h i j k l m n p q r s = {a=a,b=b,c=c};
> val r0 = fn
>   : 'a
>     -> 'b
>        -> 'c
>           -> 'd
>              -> 'e
>                 -> 'f
>                    -> 'g
>                       -> 'h
>                          -> 'i
>                             -> 'j
>                                -> 'k
>                                   -> 'l
>                                      -> 'm
>                                         -> 'n
>                                            -> 'o
>                                               -> 'p
>                                                  -> 'q
>                                                     -> 'r -> {a:'a, b:'b, c:'c}

(*) When printing a type, 'forall' is omitted. Sometimes that eliminates
(*) type variables. The following tests make sure that type variables are
(*) contiguous and numbered left-to-right.
[[], []];
> val it = [[],[]] : 'a list list
let val r = {a=[], b=[]} in r.b end;
> val it = [] : 'a list
fun f (a, b, c) = {x=c, y=a};
> val f = fn : 'a * 'b * 'c -> {x:'c, y:'a}

(* An expression whose type is complicated to infer. *)
fun f1 x = x;
> val f1 = fn : 'a -> 'a
fun f2 x = f1 (f1 x);
> val f2 = fn : 'a -> 'a
fun f3 x = f2 (f2 x);
> val f3 = fn : 'a -> 'a
fun f4 x = f3 (f3 x);
> val f4 = fn : 'a -> 'a
fun f5 x = f4 (f4 x);
> val f5 = fn : 'a -> 'a
fun f6 x = f5 (f5 x);
> val f6 = fn : 'a -> 'a
fun f7 x = f6 (f6 x);
> val f7 = fn : 'a -> 'a
fun f8 x = f7 (f7 x);
> val f8 = fn : 'a -> 'a
fun f9 x = f8 (f8 x);
> val f9 = fn : 'a -> 'a
fun f10 x = f9 (f9 x);
> val f10 = fn : 'a -> 'a
fun g y =
  let
    val a = f10 (fn z => z)
    val b = f10 (fn z => (z, z))
    val c = f10 (fn z => if true then z else y)
    val d = f10 (fn z => f10 z)
  in
    (a, b, c, d)
  end;
> val g = fn : 'a -> ('b -> 'b) * ('c -> 'c * 'c) * ('a -> 'a) * ('d -> 'd)

(* Should be able to derive type, but cannot. A bug.
   Moving 'fun f1' outside the 'let' solves the problem.
fun g2 y =
  let
    fun f1 x = x
    val a = f1 (fn w => w)
    val b = f1 (fn z => (z, z))
  in
    (a, b)
  end;
> val g2 = fn : 'a -> ('b -> 'b) * ('c -> 'c * 'c)
*)

(* Identity function, and chain functions that apply the identity
   function multiple times. *)
fun id x = x;
> val id = fn : 'a -> 'a
fun chain0 f = f;
> val chain0 = fn : 'a -> 'a
fun chain1 f = fn x => f (id x);
> val chain1 = fn : ('a -> 'b) -> 'a -> 'b
fun chain2 f = fn x => f (id (id x));
> val chain2 = fn : ('a -> 'b) -> 'a -> 'b
fun chain3 f = fn x => f (id (id (id x)));
> val chain3 = fn : ('a -> 'b) -> 'a -> 'b
fun chain4 f = fn x => f (id (id (id (id x))));
> val chain4 = fn : ('a -> 'b) -> 'a -> 'b
fun chain5 f = fn x => f (id (id (id (id (id x)))));
> val chain5 = fn : ('a -> 'b) -> 'a -> 'b
fun chain6 f = fn x => f (id (id (id (id (id (id x))))));
> val chain6 = fn : ('a -> 'b) -> 'a -> 'b
fun chain7 f = fn x => f (id (id (id (id (id (id (id x)))))));
> val chain7 = fn : ('a -> 'b) -> 'a -> 'b
fun chain8 f = fn x => f (id (id (id (id (id (id (id (id x))))))));
> val chain8 = fn : ('a -> 'b) -> 'a -> 'b
fun chain9 f = fn x => f (id (id (id (id (id (id (id (id (id x)))))))));
> val chain9 = fn : ('a -> 'b) -> 'a -> 'b
fun chain10 f = fn x => f (id (id (id (id (id (id (id (id (id (id x))))))))));
> val chain10 = fn : ('a -> 'b) -> 'a -> 'b
fun chain11 f = fn x => f (id (id (id (id (id (id (id (id (id (id (id x)))))))))));
> val chain11 = fn : ('a -> 'b) -> 'a -> 'b
fun chain12 f = fn x => f (id (id (id (id (id (id (id (id (id (id (id (id x))))))))))));
> val chain12 = fn : ('a -> 'b) -> 'a -> 'b
fun chain13 f = fn x => f (id (id (id (id (id (id (id (id (id (id (id (id (id x)))))))))))));
> val chain13 = fn : ('a -> 'b) -> 'a -> 'b
fun chain14 f = fn x => f (id (id (id (id (id (id (id (id (id (id (id (id (id (id x))))))))))))));
> val chain14 = fn : ('a -> 'b) -> 'a -> 'b
fun chain15 f = fn x => f (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id x)))))))))))))));
> val chain15 = fn : ('a -> 'b) -> 'a -> 'b
fun chain16 f = fn x => f (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id x))))))))))))))));
> val chain16 = fn : ('a -> 'b) -> 'a -> 'b
fun chain17 f = fn x => f (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id x)))))))))))))))));
> val chain17 = fn : ('a -> 'b) -> 'a -> 'b
fun chain18 f = fn x => f (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id x))))))))))))))))));
> val chain18 = fn : ('a -> 'b) -> 'a -> 'b
fun chain19 f = fn x => f (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id x)))))))))))))))))));
> val chain19 = fn : ('a -> 'b) -> 'a -> 'b
fun chain20 f = fn x => f (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id (id x))))))))))))))))))));
> val chain20 = fn : ('a -> 'b) -> 'a -> 'b

(* Helper functions for creating more complex type constraints. *)
fun apply f x = f x;
> val apply = fn : ('a -> 'b) -> 'a -> 'b
fun compose f g x = f (g x);
> val compose = fn : ('a -> 'b) -> ('c -> 'a) -> 'c -> 'b
fun flip f x y = f y x;
> val flip = fn : ('a -> 'b -> 'c) -> 'b -> 'a -> 'c
fun fst (x, _) = x;
> val fst = fn : 'a * 'b -> 'a
fun snd (_, y) = y;
> val snd = fn : 'a * 'b -> 'b

(* Data structures for creating diverse type constraints. *)
datatype ('a, 'b) either = LEFT of 'a | RIGHT of 'b;
> datatype ('a,'b) either = LEFT of 'a | RIGHT of 'b
datatype 'a tree = LEAF of 'a | NODE of 'a tree * 'a * 'a tree;
> datatype 'a tree = LEAF of 'a | NODE of 'a tree * 'a * 'a tree

(* Function that creates a quadratic unification case. *)
fun quadratic_case () =
  let
    val f0 = chain0 (fn x => x)
    val f1 = chain1 (fn x => (x, x))
    val f2 = chain2 (fn x => [x])
    val f3 = chain3 (fn x => SOME x)
    val f4 = chain4 (fn x => (x, x, x))
    val f5 = chain5 (fn x => fn y => (x, y))
    val f6 = chain6 (fn x => {field = x})
    val f7 = chain7 (fn x => if true then x else x)
    val f8 = chain8 (fn x => apply (fn y => (x, y)) x)
    val f9 = chain9 (fn x => apply (fn y => apply (fn z => (x, y, z)) y) x)
    val f10 = chain10 (fn x => LEAF x)
    val f11 = chain11 (fn x => NODE (LEAF x, x, LEAF x))
    val f12 = chain12 (fn x => LEFT x)
    val f13 = chain13 (fn x => RIGHT x)
    val f14 = chain14 (fn x => compose (fn y => (x, y)) (fn z => (z, x)))
    val f15 = chain15 (fn x => flip (fn a => fn b => (a, b, x)) x)
    val f16 = chain16 (fn x => fn y => fn z => (x, y, z))
    val f17 = chain17 (fn x => fn y => fst (x, y))
    val f18 = chain18 (fn x => fn y => snd (x, y))
    val f19 = chain19 (fn x => fn f => f x)
    val f20 = chain20 (fn x => fn f => fn g => compose f g x)
  in
    (f0, f1, f2, f3, f4, f5, f6, f7, f8, f9, f10, f11, f12, f13, f14, f15, f16, f17, f18, f19, f20)
  end;
> val quadratic_case = fn
>   : unit
>     -> ('a -> 'a) * ('b -> 'b * 'b) * ('c -> 'c list) * ('d -> 'd option) *
>        ('e -> 'e * 'e * 'e) * ('f -> 'g -> 'f * 'g) * ('h -> {field:'h}) *
>        ('i -> 'i) * ('j -> 'j * 'j) * ('k -> 'k * 'k * 'k) * ('l -> 'l tree) *
>        ('m -> 'm tree) * ('n -> ('n,'o) either) * ('p -> ('q,'p) either) *
>        ('r -> 's -> 'r * ('s * 'r)) * ('t -> 'u -> 'u * 't * 't) *
>        ('v -> 'w -> 'x -> 'v * 'w * 'x) * ('y -> 'z -> 'y) *
>        ('ba -> 'bb -> 'bb) * ('bc -> ('bc -> 'bd) -> 'bd) *
>        ('be -> ('bf -> 'bg) -> ('be -> 'bf) -> 'bg)

(* Additional function to create nested applications. *)
fun nested_quadratic_case () =
  let
    val g0 = chain10 (chain10 (fn x => x))
    val g1 = chain9 (chain11 (fn x => (x, x)))
    val g2 = chain8 (chain12 (fn x => [x]))
    val g3 = chain7 (chain13 (fn x => SOME x))
    val g4 = chain6 (chain14 (fn x => (x, x, x)))
    val g5 = chain5 (chain15 (fn x => fn y => (x, y)))
    val g6 = chain4 (chain16 (fn x => {field = x}))
    val g7 = chain3 (chain17 (fn x => if true then x else x))
    val g8 = chain2 (chain18 (fn x => LEAF x))
    val g9 = chain1 (chain19 (fn x => NODE (LEAF x, x, LEAF x)))
    val g10 = chain0 (chain20 (fn x => LEFT x))
  in
    (g0, g1, g2, g3, g4, g5, g6, g7, g8, g9, g10)
  end;
> val nested_quadratic_case = fn
>   : unit
>     -> ('a -> 'a) * ('b -> 'b * 'b) * ('c -> 'c list) * ('d -> 'd option) *
>        ('e -> 'e * 'e * 'e) * ('f -> 'g -> 'f * 'g) * ('h -> {field:'h}) *
>        ('i -> 'i) * ('j -> 'j tree) * ('k -> 'k tree) * ('l -> ('l,'m) either)

(* Cross-chain dependencies for even more complexity. *)
fun cross_chain () =
  let
    val h0 = chain0 (chain10 (fn x => x))
    val h1 = chain1 (chain9 (fn x => (x, x)))
    val h2 = chain2 (chain8 (fn x => [x]))
    val h3 = chain3 (chain7 (fn x => SOME x))
    val h4 = chain4 (chain6 (fn x => (x, x, x)))
    val h5 = chain5 (chain5 (fn x => fn y => (x, y)))
    val h6 = chain6 (chain4 (fn x => {field = x}))
    val h7 = chain7 (chain3 (fn x => if true then x else x))
    val h8 = chain8 (chain2 (fn x => apply (fn y => (x, y)) x))
    val h9 = chain9 (chain1 (fn x => apply (fn y => apply (fn z => (x, y, z)) y) x))
    val h10 = chain10 (chain0 (fn x => LEAF x))
  in
    (h0, h1, h2, h3, h4, h5, h6, h7, h8, h9, h10)
  end;
> val cross_chain = fn
>   : unit
>     -> ('a -> 'a) * ('b -> 'b * 'b) * ('c -> 'c list) * ('d -> 'd option) *
>        ('e -> 'e * 'e * 'e) * ('f -> 'g -> 'f * 'g) * ('h -> {field:'h}) *
>        ('i -> 'i) * ('j -> 'j * 'j) * ('k -> 'k * 'k * 'k) * ('l -> 'l tree)

(* Test all the cases *)
val all_cases = (quadratic_case(), nested_quadratic_case(), cross_chain());
> val all_cases =
>   ((fn,fn,fn,fn,fn,fn,fn,fn,fn,fn,fn,fn,fn,fn,fn,fn,fn,fn,fn,fn,fn),
>    (fn,fn,fn,fn,fn,fn,fn,fn,fn,fn,fn),(fn,fn,fn,fn,fn,fn,fn,fn,fn,fn,fn))
>   :
>     ('a -> 'a) * ('b -> 'b * 'b) * ('c -> 'c list) * ('d -> 'd option) *
>     ('e -> 'e * 'e * 'e) * ('f -> 'g -> 'f * 'g) * ('h -> {field:'h}) *
>     ('i -> 'i) * ('j -> 'j * 'j) * ('k -> 'k * 'k * 'k) * ('l -> 'l tree) *
>     ('m -> 'm tree) * ('n -> ('n,'o) either) * ('p -> ('q,'p) either) *
>     ('r -> 's -> 'r * ('s * 'r)) * ('t -> 'u -> 'u * 't * 't) *
>     ('v -> 'w -> 'x -> 'v * 'w * 'x) * ('y -> 'z -> 'y) * ('ba -> 'bb -> 'bb)
>      * ('bc -> ('bc -> 'bd) -> 'bd) *
>     ('be -> ('bf -> 'bg) -> ('be -> 'bf) -> 'bg) *
>     (
>     ('bh -> 'bh) * ('bi -> 'bi * 'bi) * ('bj -> 'bj list) * ('bk -> 'bk option)
>      * ('bl -> 'bl * 'bl * 'bl) * ('bm -> 'bn -> 'bm * 'bn) *
>     ('bo -> {field:'bo}) * ('bp -> 'bp) * ('bq -> 'bq tree) * ('br -> 'br tree)
>      * ('bs -> ('bs,'bt) either)) *
>     (
>     ('bu -> 'bu) * ('bv -> 'bv * 'bv) * ('bw -> 'bw list) * ('bx -> 'bx option)
>      * ('by -> 'by * 'by * 'by) * ('bz -> 'ca -> 'bz * 'ca) *
>     ('cb -> {field:'cb}) * ('cc -> 'cc) * ('cd -> 'cd * 'cd) *
>     ('ce -> 'ce * 'ce * 'ce) * ('cf -> 'cf tree))

(*) End type.smli
