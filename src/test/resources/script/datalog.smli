(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *)
Sys.set ("printDepth", ~1);
> val it = () : unit
Sys.set ("printLength", ~1);
> val it = () : unit
Sys.set ("lineWidth", 78);
> val it = () : unit
Sys.set ("stringDepth", ~1);
> val it = () : unit

(*) Basic validation - valid program
val program = ".decl edge(x:number, y:number)
edge(1,2).
edge(2,3).
.output edge";
> val program =
>   ".decl edge(x:number, y:number)\nedge(1,2).\nedge(2,3).\n.output edge"
>   : string

Datalog.validate program;
> val it = "{edge:{x:int, y:int} bag}" : string

Datalog.execute program;
> val it = {edge=[{x=1,y=2},{x=2,y=3}]} : {edge:{x:int, y:int} bag} variant

Datalog.translate program;
> val it =
>   SOME "let\n  val edge_facts = [(1, 2), (2, 3)]\n  fun edge (x, y) = (x, y) elem edge_facts\nin\n  {edge = from x, y where edge (x, y)}\nend"
>   : string option

(*) Basic validation - parse error
Datalog.validate ".decl edge(x:number";
> val it =
>   "Parse error: Encountered \"<EOF>\" at line 1, column 19.\nWas expecting one of:\n    \")\" ...\n    \",\" ...\n    "
>   : string

(*) Schema validation - arity mismatch in fact
Datalog.validate ".decl edge(x:number, y:number)
edge(1,2,3).";
> val it = "Compilation error: Atom edge/3 does not match declaration edge/2"
>   : string

(*) Schema validation - arity mismatch in rule head
Datalog.validate ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
path(X,Y,Z) :- edge(X,Y).";
> val it = "Compilation error: Atom path/3 does not match declaration path/2"
>   : string

(*) Schema validation - arity mismatch in rule body
Datalog.validate ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
path(X,Y) :- edge(X).";
> val it = "Compilation error: Atom edge/1 does not match declaration edge/2"
>   : string

(*) Schema validation - undeclared relation
Datalog.validate ".decl edge(x:number, y:number)
path(1,2).";
> val it = "Compilation error: Relation 'path' used in fact but not declared"
>   : string

(*) Safety - unsafe rule (variable in head not in body)
Datalog.validate ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
path(X,Y) :- edge(X,Z).";
> val it =
>   "Compilation error: Rule is unsafe. Variable 'Y' in head does not appear in positive body atom"
>   : string

(*) Safety - unsafe negation (variable only in negated atom)
Datalog.validate ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
path(X,Y) :- edge(X,Z), !edge(Y,W).";
> val it =
>   "Compilation error: Rule is unsafe. Variable 'Y' in head does not appear in positive body atom"
>   : string

(*) Stratification - negation cycle
Datalog.validate ".decl edge(x:number, y:number)
.decl p(x:number)
.decl q(x:number)
edge(1,2).
p(X) :- edge(X,Y), !q(X).
q(X) :- edge(X,Y), !p(X).";
> val it =
>   "Compilation error: Program is not stratified. Negation cycle detected involving relation: p"
>   : string

(*) Stratification - valid stratified program
Datalog.execute ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
edge(1,2).
path(X,Y) :- edge(X,Y).
path(X,Z) :- path(X,Y), edge(Y,Z).
.output path";
> val it = {path=[{x=1,y=2}]} : {path:{x:int, y:int} bag} variant

(*) Multiple .output directives
Datalog.execute ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
edge(1,2).
path(X,Y) :- edge(X,Y).
.output edge
.output path";
> val it = {edge=[{x=1,y=2}],path=[{x=1,y=2}]}
>   : {edge:{x:int, y:int} bag, path:{x:int, y:int} bag} variant

(*) Basic facts - number type
Datalog.execute ".decl num(n:number)
num(42).
num(0).
.output num";
> val it = {num=[42,0]} : {num:int bag} variant

(*) Basic facts - string type
Datalog.execute ".decl person(name:string)
person(\"Alice\").
person(\"Bob\").
.output person";
> val it = {person=["Alice","Bob"]} : {person:string bag} variant

(*) Basic facts - symbol type (now using string type since Souffle has no symbols)
Datalog.execute ".decl color(c:string)
color(\"red\").
color(\"blue\").
color(\"green\").
.output color";
> val it = {color=["red","blue","green"]} : {color:string bag} variant

(*) Basic facts - mixed types
Datalog.execute ".decl employee(name:string, age:number, dept:string)
employee(\"Alice\", 30, \"engineering\").
employee(\"Bob\", 25, \"sales\").
.output employee";
> val it =
>   {
>    employee=
>    [{age=30,dept="engineering",name="Alice"},{age=25,dept="sales",name="Bob"}]}
>   : {employee:{age:int, dept:string, name:string} bag} variant

(*) Basic facts - more than one output
Datalog.execute ".decl employee(name:string, age:number, dept:number)
.decl department(name:string, dept:number)
employee(\"Alice\", 30, 10).
employee(\"Bob\", 25, 20).
department(\"Sales\", 20).
department(\"Engineering\", 10).
.output employee
.output department";
> val it =
>   {department=[{dept=20,name="Sales"},{dept=10,name="Engineering"}],
>    employee=[{age=30,dept=10,name="Alice"},{age=25,dept=20,name="Bob"}]}
>   : {department:{dept:int, name:string} bag,
>      employee:{age:int, dept:int, name:string} bag} variant

(*) Basic facts - no output
Datalog.execute ".decl employee(name:string, age:number, dept:number)
.decl department(name:string, dept:number)
employee(\"Alice\", 30, 10).
employee(\"Bob\", 25, 20).
department(\"Sales\", 20).
department(\"Engineering\", 10).";
> val it = () : unit variant

(*) Type mismatch - number for string
Datalog.validate ".decl person(name:string)
person(42).";
> val it =
>   "Compilation error: Type mismatch in fact person(...): expected string, got number for parameter name"
>   : string

(*) Type mismatch - string for number
Datalog.validate ".decl num(n:number)
num(\"hello\").";
> val it =
>   "Compilation error: Type mismatch in fact num(...): expected number, got string for parameter n"
>   : string

(*) Variables in facts are not allowed
Datalog.validate ".decl num(n:number)
num(Foo).";
> val it = "Compilation error: Argument in fact is not constant: Foo" : string

(* Transitive closure

   Input graph:
        1 ---> 2 ---> 3
*)
val program = ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
edge(1,2).
edge(2,3).
path(X,Y) :- edge(X,Y).
path(X,Z) :- path(X,Y), edge(Y,Z).
.output path";
> val program =
>   ".decl edge(x:number, y:number)\n.decl path(x:number, y:number)\nedge(1,2).\nedge(2,3).\npath(X,Y) :- edge(X,Y).\npath(X,Z) :- path(X,Y), edge(Y,Z).\n.output path"
>   : string
Datalog.execute program;
> val it = {path=[{x=1,y=2},{x=2,y=3},{x=1,y=3}]}
>   : {path:{x:int, y:int} bag} variant
Datalog.translate program;
> val it =
>   SOME "let\n  val edge_facts = [(1, 2), (2, 3)]\n  fun edge (x, y) = (x, y) elem edge_facts\n  fun path (x, y) =\n    edge (x, y) orelse\n    (exists v0 where path (x, v0) andalso edge (v0, y))\nin\n  {path = from x, y where path (x, y)}\nend"
>   : string option

(*) Simple rule - join
Datalog.execute ".decl parent(p:string, c:string)
.decl sibling(x:string, y:string)
parent(\"Alice\", \"Bob\").
parent(\"Alice\", \"Carol\").
sibling(X,Y) :- parent(P,X), parent(P,Y).
.output sibling";
> val it =
>   {
>    sibling=
>    [{x="Bob",y="Bob"},{x="Bob",y="Carol"},{x="Carol",y="Bob"},
>     {x="Carol",y="Carol"}]} : {sibling:{x:string, y:string} bag} variant

(*) Join, avoiding symmetric
Datalog.execute ".decl parent(p:string, c:string)
.decl sibling(x:string, y:string)
parent(\"Alice\", \"Bob\").
parent(\"Alice\", \"Carol\").
sibling(X,Y) :- parent(P,X), parent(P,Y), X != Y.
.output sibling";
> val it = {sibling=[{x="Bob",y="Carol"},{x="Carol",y="Bob"}]}
>   : {sibling:{x:string, y:string} bag} variant

(*) Join, avoiding symmetric and duplicates
Datalog.execute ".decl parent(p:string, c:string)
.decl sibling(x:string, y:string)
parent(\"Alice\", \"Bob\").
parent(\"Alice\", \"Carol\").
sibling(X,Y) :- parent(P,X), parent(P,Y), X < Y.
.output sibling";
> val it = {sibling=[{x="Bob",y="Carol"}]}
>   : {sibling:{x:string, y:string} bag} variant

(*) Negation - set difference
Datalog.execute ".decl student(name:string)
.decl graduate(name:string)
.decl undergraduate(name:string)
student(\"Alice\").
student(\"Bob\").
graduate(\"Alice\").
undergraduate(X) :- student(X), !graduate(X).
.output undergraduate";
> val it = {undergraduate=["Bob"]} : {undergraduate:string bag} variant

(*) Complex example - ancestor queries
Datalog.execute ".decl parent(p:string, c:string)
.decl ancestor(a:string, d:string)
.decl descendant(p:string, d:string)
parent(\"Alice\", \"Bob\").
parent(\"Bob\", \"Carol\").
parent(\"Carol\", \"Dan\").
ancestor(P,C) :- parent(P,C).
ancestor(A,D) :- ancestor(A,X), parent(X,D).
descendant(P,D) :- ancestor(D,P).
.output ancestor
.output descendant";
> val it =
>   {
>    ancestor=
>    [{a="Alice",d="Bob"},{a="Bob",d="Carol"},{a="Carol",d="Dan"},
>     {a="Alice",d="Carol"},{a="Bob",d="Dan"},{a="Alice",d="Dan"}],
>    descendant=
>    [{d="Alice",p="Bob"},{d="Bob",p="Carol"},{d="Carol",p="Dan"},
>     {d="Alice",p="Carol"},{d="Bob",p="Dan"},{d="Alice",p="Dan"}]}
>   : {ancestor:{a:string, d:string} bag, descendant:{d:string, p:string} bag} variant

(*) Empty relation
Datalog.validate ".decl empty(x:number)
.output empty";
> val it = "{empty:'a list}" : string

(*) Comments in Datalog
Datalog.execute "// Line comment
.decl edge(x:number, y:number)
/* Block comment */
edge(1,2).
.output edge";
> val it = {edge=[{x=1,y=2}]} : {edge:{x:int, y:int} bag} variant

(*) Execution - basic facts
Datalog.execute ".decl num(n:number)
num(1).
num(2).
num(3).
.output num";
> val it = {num=[1,2,3]} : {num:int bag} variant

(*) Execution - transitive closure
Datalog.execute ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
edge(1,2).
edge(2,3).
path(X,Y) :- edge(X,Y).
path(X,Z) :- path(X,Y), edge(Y,Z).
.output path";
> val it = {path=[{x=1,y=2},{x=2,y=3},{x=1,y=3}]}
>   : {path:{x:int, y:int} bag} variant

(*
Translated:

fun edge(x, y) = (x, y) elem [(1, 2), (2, 3)];
fun path(x, z) = edge(x, z)
 orelse (exists y where path(x, y) andalso edge(y, z));
from x, z where path(x, z);

Expanded:

fun edge(x, y) = (x, y) elem [(1, 2), (2, 3)];
> val edge = fn : int * int -> bool
fun path(x, z) = edge(x, z) orelse
  (exists y in [1,2,3] where path(x, y) andalso edge(y, z));
> val path = fn : int * int -> bool
from x in [1,2,3], z in [1,2,3] where path(x, z);

*)

(*) Comparison operators - less than
Datalog.execute ".decl num(n:number)
.decl small(n:number)
num(1).
num(5).
num(10).
small(X) :- num(X), X < 7.
.output small";
> val it = {small=[1,5]} : {small:int bag} variant

(*) Comparison operators - greater than or equal
Datalog.execute ".decl num(n:number)
.decl large(n:number)
num(1).
num(5).
num(10).
large(X) :- num(X), X >= 5.
.output large";
> val it = {large=[5,10]} : {large:int bag} variant

(*) Comparison operators - not equal
Datalog.execute ".decl num(n:number)
.decl not_five(n:number)
num(1).
num(5).
num(10).
not_five(X) :- num(X), X != 5.
.output not_five";
> val it = {not_five=[1,10]} : {not_five:int bag} variant

(*) Comparison operators - equal
Datalog.execute ".decl edge(x:number, y:number)
.decl self_loop(x:number)
edge(1, 1).
edge(2, 3).
edge(4, 4).
self_loop(X) :- edge(X, Y), X = Y.
.output self_loop";
> val it = {self_loop=[1,4]} : {self_loop:int bag} variant

(*) Comparison operators - contains
(* TODO: implement contains
Datalog.execute ".decl stringTable(t:symbol)
.decl substringTable(t:symbol)
.decl outputData(substr:symbol, str:symbol)
.output outputData
outputData(x,y) :- substringTable(x), stringTable(y), contains(x,y).
stringTable(\"aaaa\").
stringTable(\"abba\").
stringTable(\"bcab\").
stringTable(\"bdab\").
substringTable(\"a\").
substringTable(\"ab\").
substringTable(\"cab\")."

Output:
a  aaaa
a  abba
a  bcab
a  bdab
ab  abba
ab  bcab
ab  bdab
cab  bcab
*)

(*) Comparison operators - match
(* TODO: implement match
Datalog.execute ".decl inputData(t:symbol)
.decl outputData(t:symbol)
.output outputData
outputData(x) :- inputData(x), match("a.*",x).
inputData(\"aaaa\").
inputData(\"abba\").
inputData(\"bcab\").
inputData(\"bdab\").";
> val it = {outputData = "aaaa", "abba"} : {outputData:string list} variant
*)

(*) TODO true rule
(*) TODO false rule

(* Multiple heads
 *
 * A(x,y), C(x,y) :- B(x,y).
 *
 * is syntactic sugar for
 *
 * A(x,y) :- B(x,y).
 * C(x,y) :- B(x,y).
 *
 * express edge/path using multiple heads.
 *)
(* TODO implement multiple heads
Datalog.execute ".decl reversed_edge(x:number, y:number)
.decl edge(x:number, y:number)
.decl path(x:number, y:number)
reversed_edge(2,1).
reversed_edge(3,2).
path(X,Y), edge(X,Y) :- reversed_edge(Y,X).
path(X,Z) :- path(X,Y), edge(Y,Z).
.output path";
*)

(* Multiple facts are not allowed. *)
(* Souffle gives 'Error: syntax error, unexpected ., expecting :- or ","'. *)
(* TODO implement multiple heads
Datalog.validate ".decl num(n:number)
num(1), num(2), num(3).
.output num";
> val it = "an error" : string
*)

(* -------------------------------------------------------------- *)
(* Factorial *)

(* The translate works but execute cannot yet evaluate recursive
 * predicates with arithmetic that create new integer values
 * (predicate-inversion cannot handle unbounded integers). *)
Datalog.translate ".decl fact(n:number, value:number)
fact(0, 1).
fact(N + 1, value * (N + 1)) :- fact(N, value), N < 10.
.output fact";
> val it =
>   SOME "let\n  val fact_facts = [(0, 1)]\n  fun fact (n, value) =\n    (n, value) elem fact_facts orelse\n    (exists v0 where fact (n - 1, v0) andalso n - 1 < 10 andalso value = v0 * (n - 1 + 1))\nin\n  {fact = from n, value where fact (n, value)}\nend"
>   : string option

(* -------------------------------------------------------------- *)
(* Fibonacci sequence *)

(* Not valid, because the variable idx is not bound as an argument
 * of a positive predicate in the body. In the example, variable
 * idx occurs in the predicates fib(idx-1, x) and fib(idx-2, y)
 * but as arguments of a functor rather than as a direct
 * argument. *)
Datalog.validate ".decl fib(idx:number, value:number)
fib(1,1).
fib(2,1).
fib(idx, x + y) :- fib(idx - 1, x), fib(idx - 2, y), idx <= 10.
.output fib";
> val it =
>   "Compilation error: Rule is unsafe. Variable 'idx' in head does not appear in positive body atom"
>   : string

(* To make variable idx bound, we can shift the index by one and
 * obtain a program whose variables are grounded.
 *
 * The translate works but execute cannot yet evaluate recursive
 * predicates with arithmetic that create new integer values
 * (predicate-inversion cannot handle unbounded integers). *)
Datalog.translate ".decl fib(idx:number, value:number)
fib(1,1).
fib(2,1).
fib(idx + 1, x + y) :- fib(idx, x), fib(idx - 1, y), idx <= 9.
.output fib";
> val it =
>   SOME "let\n  val fib_facts = [(1, 1), (2, 1)]\n  fun fib (idx, value) =\n    (idx, value) elem fib_facts orelse\n    (exists v0, v1 where fib (idx - 1, v0) andalso fib (idx - 1 - 1, v1) andalso idx - 1 <= 9 andalso value = v0 + v1)\nin\n  {fib = from idx, value where fib (idx, value)}\nend"
>   : string option

(* -------------------------------------------------------------- *)
(* Queries for existence of odd cycle.
 *
 * "Linear Datalog and bounded path duality of relational structures"
 * (Dalmau, 2004) gives the query more concisely as
 *
 *   P(x,y) :- E(x,y)
 *   P(x,y) :- P(x,z),E(z,u),E(u,y)
 *   Q :- P(x,x)
 *)
Datalog.execute ".decl edge(x:symbol, y:symbol)
.decl odd_path(x:symbol, y:symbol)
.decl exists_odd_cycle()
edge(\"a\", \"b\").
edge(\"b\", \"c\").
edge(\"c\", \"a\").
odd_path(X,Y) :- edge(X,Y).
odd_path(X,Y) :- odd_path(X,Z), edge(Z,U), edge(U,Y).
exists_odd_cycle() :- odd_path(X,X).
.output exists_odd_cycle";
> val it = {exists_odd_cycle=[()]} : {exists_odd_cycle:unit list} variant

(*) Same query on a data set that has an even cycle but no odd cycle.
Datalog.execute ".decl edge(x:symbol, y:symbol)
.decl odd_path(x:symbol, y:symbol)
.decl exists_odd_cycle()
edge(\"a\", \"b\").
edge(\"b\", \"c\").
edge(\"b\", \"a\").
odd_path(X,Y) :- edge(X,Y).
odd_path(X,Y) :- odd_path(X,Z), edge(Z,U), edge(U,Y).
exists_odd_cycle() :- odd_path(X,X).
.output exists_odd_cycle";
> val it = {exists_odd_cycle=[()]} : {exists_odd_cycle:unit list} variant

(* -------------------------------------------------------------- *)
(*
 * The next few queries perform transitive closure and bounded
 * transitive closure over a graph. They all use the following
 * graph.
 *
 *   a ---> b ---> c ---> d ---> e ---> f
 *   |             ^
 *   +-------------+
 *
 * From a: b is 1 hop, c is 1 hop (shortcut), d is 2 hops (a->c->d),
 * e is 3 hops (a->c->d->e), f is 4 hops (a->c->d->e->f).
 *)

(*) Transitive closure
Datalog.execute ".decl edge(x:string, y:string)
.decl path(x:string, y:string)
edge(\"a\", \"b\").
edge(\"b\", \"c\").
edge(\"c\", \"d\").
edge(\"d\", \"e\").
edge(\"e\", \"f\").
edge(\"a\", \"c\").
path(X,Y) :- edge(X,Y).
path(X,Z) :- path(X,Y), edge(Y,Z).
.output path";
> val it =
>   {
>    path=
>    [{x="a",y="b"},{x="b",y="c"},{x="c",y="d"},{x="d",y="e"},{x="e",y="f"},
>     {x="a",y="c"},{x="b",y="d"},{x="a",y="d"},{x="c",y="e"},{x="d",y="f"},
>     {x="b",y="e"},{x="a",y="e"},{x="c",y="f"},{x="b",y="f"},{x="a",y="f"}]}
>   : {path:{x:string, y:string} bag} variant

(*) Shortest path - computing reachability at different hop counts
Datalog.execute ".decl edge(x:string, y:string)
.decl reach1(x:string, y:string)
.decl reach2(x:string, y:string)
edge(\"a\", \"b\").
edge(\"b\", \"c\").
edge(\"c\", \"d\").
edge(\"d\", \"e\").
edge(\"e\", \"f\").
edge(\"a\", \"c\").
reach1(X, Y) :- edge(X, Y).
reach2(X, Z) :- edge(X, Y), edge(Y, Z).
.output reach1
.output reach2";
> val it =
>   {
>    reach1=
>    [{x="a",y="b"},{x="b",y="c"},{x="c",y="d"},{x="d",y="e"},{x="e",y="f"},
>     {x="a",y="c"}],
>    reach2=
>    [{x="a",y="c"},{x="b",y="d"},{x="c",y="e"},{x="d",y="f"},{x="a",y="d"}]}
>   : {reach1:{x:string, y:string} bag, reach2:{x:string, y:string} bag} variant

(*
 * Shortest path with distance parameter.
 *
 * This is the standard way to express shortest path in Datalog:
 *  - Base case: direct edges have distance 1
 *  - Recursive case: extend a path by one edge, incrementing distance
 *)
Datalog.translate ".decl edge(x:string, y:string)
.decl path(x:string, y:string, n:number)
edge(\"a\", \"b\").
edge(\"b\", \"c\").
edge(\"c\", \"d\").
edge(\"d\", \"e\").
edge(\"e\", \"f\").
edge(\"a\", \"c\").
path(X, Y, 1) :- edge(X, Y).
path(X, Z, N+1) :- path(X, Y, N), edge(Y, Z).
.output path";
> val it =
>   SOME "let\n  val edge_facts = [(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"e\"), (\"e\", \"f\"), (\"a\", \"c\")]\n  fun edge (x, y) = (x, y) elem edge_facts\n  fun path (x, y, n) =\n    edge (x, y) andalso n = 1 orelse\n    (exists v0 where path (x, v0, n - 1) andalso edge (v0, y))\nin\n  {path = from x, y, n where path (x, y, n)}\nend"
>   : string option
(*
> val it =
>   {path=[{n=1,x="a",y="b"},{n=1,x="b",y="c"},{n=1,x="c",y="d"},
>     {n=1,x="d",y="e"},{n=1,x="e",y="f"},{n=1,x="a",y="c"},
>     {n=2,x="a",y="c"},{n=2,x="b",y="d"},{n=2,x="c",y="e"},
>     {n=2,x="d",y="f"},{n=2,x="a",y="d"},
>     {n=3,x="a",y="d"},{n=3,x="b",y="e"},{n=3,x="c",y="f"},
>     {n=3,x="a",y="e"},
>     {n=4,x="a",y="e"},{n=4,x="b",y="f"},{n=4,x="a",y="f"},
>     {n=5,x="a",y="f"}]}
>   : {path:{n:int, x:string, y:string} bag} variant
*)

(*
 * Shortest path using aggregation - Datalog with min
 *
 * An alternative formulation uses 'min' aggregation to find the
 * shortest distance among all paths. First compute all paths with
 * their distances, then select the minimum.
 *
 * Note: This requires both arithmetic (N+1) and aggregation (min),
 * neither of which is yet supported.
 *)
(* TODO
Datalog.execute ".decl edge(x:string, y:string)
.decl dist(x:string, y:string, n:number)
.decl shortest(x:string, y:string, n:number)
edge(\"a\", \"b\").
edge(\"b\", \"c\").
edge(\"c\", \"d\").
edge(\"d\", \"e\").
edge(\"e\", \"f\").
edge(\"a\", \"c\").
dist(X, Y, 1) :- edge(X, Y).
dist(X, Z, N+1) :- dist(X, Y, N), edge(Y, Z).
shortest(X, Y, min N) :- dist(X, Y, N).
.output shortest";
*)

(*
 * Bounded transitive closure - find all paths of length <= 3.
 *
 * This query finds all pairs (X, Y) reachable in at most 3 hops.
 * The bound is a parameter, not hardcoded as separate reach1, reach2,
 * reach3 relations. The guard N < 3 in the recursive rule stops
 * extension beyond the bound.
 *
 * From a: e is reachable (3 hops: a->c->d->e) but f is not (4 hops).
 * The translate works but execute cannot yet handle 3-arity recursive
 * predicates with arithmetic (such-that evaluator cannot enumerate
 * unbounded integers).
 *)
Datalog.translate ".decl edge(x:string, y:string)
.decl path(x:string, y:string, n:number)
edge(\"a\", \"b\").
edge(\"b\", \"c\").
edge(\"c\", \"d\").
edge(\"d\", \"e\").
edge(\"e\", \"f\").
edge(\"a\", \"c\").
path(X, Y, 1) :- edge(X, Y).
path(X, Z, N+1) :- path(X, Y, N), edge(Y, Z), N < 3.
.output path";
> val it =
>   SOME "let\n  val edge_facts = [(\"a\", \"b\"), (\"b\", \"c\"), (\"c\", \"d\"), (\"d\", \"e\"), (\"e\", \"f\"), (\"a\", \"c\")]\n  fun edge (x, y) = (x, y) elem edge_facts\n  fun path (x, y, n) =\n    edge (x, y) andalso n = 1 orelse\n    (exists v0 where path (x, v0, n - 1) andalso edge (v0, y) andalso n - 1 < 3)\nin\n  {path = from x, y, n where path (x, y, n)}\nend"
>   : string option

(* -------------------------------------------------------------- *)
(* .input directive - read facts from CSV file *)

(*) Read a relation from CSV and output it directly
Datalog.execute ".decl dept(deptno:number, dname:string, loc:string)
.input dept \"data/scott/depts.csv\"
.output dept";
> val it =
>   {
>    dept=
>    [{deptno=10,dname="ACCOUNTING",loc="NEW YORK"},
>     {deptno=20,dname="RESEARCH",loc="DALLAS"},
>     {deptno=30,dname="SALES",loc="CHICAGO"},
>     {deptno=40,dname="OPERATIONS",loc="BOSTON"}]}
>   : {dept:{deptno:int, dname:string, loc:string} bag} variant

(*) Which states adjoin both Florida and Tennessee?
Datalog.execute ".decl adj(state:string, adjacent:string)
.decl result(state:string)
.input adj \"data/map/adjacent-states.csv\"
result(state) :- adj(state, \"FL\"), adj(state, \"TN\").
.output result";
> val it = {result=["AL","GA"]} : {result:string bag} variant

(*) End datalog.smli
