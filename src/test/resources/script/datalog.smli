(*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 *)
Sys.set ("printDepth", ~1);
> val it = () : unit
Sys.set ("lineWidth", 78);
> val it = () : unit
Sys.set ("stringDepth", ~1);
> val it = () : unit

(*) Basic validation - valid program
val program = ".decl edge(x:number, y:number)
edge(1,2).
edge(2,3).
.output edge";
> val program =
>   ".decl edge(x:number, y:number)\nedge(1,2).\nedge(2,3).\n.output edge"
>   : string

Datalog.validate program;
> val it = "{edge:{x:int, y:int} bag}" : string

Datalog.execute program;
> val it = {edge=[{x=1,y=2},{x=2,y=3}]} : {edge:{x:int, y:int} bag} variant

Datalog.translate program;
> val it =
>   SOME "let\n  val edge_facts = [(1, 2), (2, 3)]\n  fun edge (x, y) = (x, y) elem edge_facts\nin\n  {edge = from x, y where edge (x, y)}\nend"
>   : string option

(*) Basic validation - parse error
Datalog.validate ".decl edge(x:number";
> val it =
>   "Parse error: Encountered \"<EOF>\" at line 1, column 19.\nWas expecting one of:\n    \")\" ...\n    \",\" ...\n    "
>   : string

(*) Schema validation - arity mismatch in fact
Datalog.validate ".decl edge(x:number, y:number)
edge(1,2,3).";
> val it = "Compilation error: Atom edge/3 does not match declaration edge/2"
>   : string

(*) Schema validation - arity mismatch in rule head
Datalog.validate ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
path(X,Y,Z) :- edge(X,Y).";
> val it = "Compilation error: Atom path/3 does not match declaration path/2"
>   : string

(*) Schema validation - arity mismatch in rule body
Datalog.validate ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
path(X,Y) :- edge(X).";
> val it = "Compilation error: Atom edge/1 does not match declaration edge/2"
>   : string

(*) Schema validation - undeclared relation
Datalog.validate ".decl edge(x:number, y:number)
path(1,2).";
> val it = "Compilation error: Relation 'path' used in fact but not declared"
>   : string

(*) Safety - unsafe rule (variable in head not in body)
Datalog.validate ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
path(X,Y) :- edge(X,Z).";
> val it =
>   "Compilation error: Rule is unsafe. Variable 'Y' in head does not appear in positive body atom"
>   : string

(*) Safety - unsafe negation (variable only in negated atom)
Datalog.validate ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
path(X,Y) :- edge(X,Z), !edge(Y,W).";
> val it =
>   "Compilation error: Rule is unsafe. Variable 'Y' in head does not appear in positive body atom"
>   : string

(*) Stratification - negation cycle
Datalog.validate ".decl edge(x:number, y:number)
.decl p(x:number)
.decl q(x:number)
edge(1,2).
p(X) :- edge(X,Y), !q(X).
q(X) :- edge(X,Y), !p(X).";
> val it =
>   "Compilation error: Program is not stratified. Negation cycle detected involving relation: p"
>   : string

(*) Stratification - valid stratified program
Datalog.execute ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
edge(1,2).
path(X,Y) :- edge(X,Y).
path(X,Z) :- path(X,Y), edge(Y,Z).
.output path";
> val it = {path=[{x=1,y=2}]} : {path:{x:int, y:int} bag} variant

(*) Multiple .output directives
Datalog.execute ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
edge(1,2).
path(X,Y) :- edge(X,Y).
.output edge
.output path";
> val it = {edge=[{x=1,y=2}],path=[{x=1,y=2}]}
>   : {edge:{x:int, y:int} bag, path:{x:int, y:int} bag} variant

(*) Basic facts - number type
Datalog.execute ".decl num(n:number)
num(42).
num(0).
.output num";
> val it = {num=[42,0]} : {num:int bag} variant

(*) Basic facts - string type
Datalog.execute ".decl person(name:string)
person(\"Alice\").
person(\"Bob\").
.output person";
> val it = {person=["Alice","Bob"]} : {person:string bag} variant

(*) Basic facts - symbol type (now using string type since Souffle has no symbols)
Datalog.execute ".decl color(c:string)
color(\"red\").
color(\"blue\").
color(\"green\").
.output color";
> val it = {color=["red","blue","green"]} : {color:string bag} variant

(*) Basic facts - mixed types
Datalog.execute ".decl employee(name:string, age:number, dept:string)
employee(\"Alice\", 30, \"engineering\").
employee(\"Bob\", 25, \"sales\").
.output employee";
> val it =
>   {
>    employee=
>    [{age=30,dept="engineering",name="Alice"},{age=25,dept="sales",name="Bob"}]}
>   : {employee:{age:int, dept:string, name:string} bag} variant

(*) Basic facts - more than one output
Datalog.execute ".decl employee(name:string, age:number, dept:number)
.decl department(name:string, dept:number)
employee(\"Alice\", 30, 10).
employee(\"Bob\", 25, 20).
department(\"Sales\", 20).
department(\"Engineering\", 10).
.output employee
.output department";
> val it =
>   {department=[{dept=20,name="Sales"},{dept=10,name="Engineering"}],
>    employee=[{age=30,dept=10,name="Alice"},{age=25,dept=20,name="Bob"}]}
>   : {department:{dept:int, name:string} bag,
>      employee:{age:int, dept:int, name:string} bag} variant

(*) Basic facts - no output
Datalog.execute ".decl employee(name:string, age:number, dept:number)
.decl department(name:string, dept:number)
employee(\"Alice\", 30, 10).
employee(\"Bob\", 25, 20).
department(\"Sales\", 20).
department(\"Engineering\", 10).";
> val it = () : unit variant

(*) Type mismatch - number for string
Datalog.validate ".decl person(name:string)
person(42).";
> val it =
>   "Compilation error: Type mismatch in fact person(...): expected string, got number for parameter name"
>   : string

(*) Type mismatch - string for number
Datalog.validate ".decl num(n:number)
num(\"hello\").";
> val it =
>   "Compilation error: Type mismatch in fact num(...): expected number, got string for parameter n"
>   : string

(*) Variables in facts are not allowed
Datalog.validate ".decl num(n:number)
num(Foo).";
> val it = "Compilation error: Argument in fact is not constant: Foo" : string

(*) Transitive closure
val program = ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
edge(1,2).
edge(2,3).
path(X,Y) :- edge(X,Y).
path(X,Z) :- path(X,Y), edge(Y,Z).
.output path";
> val program =
>   ".decl edge(x:number, y:number)\n.decl path(x:number, y:number)\nedge(1,2).\nedge(2,3).\npath(X,Y) :- edge(X,Y).\npath(X,Z) :- path(X,Y), edge(Y,Z).\n.output path"
>   : string
Datalog.execute program;
> val it = {path=[{x=1,y=2},{x=2,y=3},{x=1,y=3}]}
>   : {path:{x:int, y:int} bag} variant
Datalog.translate program;
> val it =
>   SOME "let\n  val edge_facts = [(1, 2), (2, 3)]\n  fun edge (x, y) = (x, y) elem edge_facts\n  fun path (x, y) =\n    edge (x, y) orelse\n    (exists v0 where path (x, v0) andalso edge (v0, y))\nin\n  {path = from x, y where path (x, y)}\nend"
>   : string option

(*) Simple rule - join
Datalog.validate ".decl parent(p:string, c:string)
.decl sibling(x:string, y:string)
parent(\"Alice\", \"Bob\").
parent(\"Alice\", \"Carol\").
sibling(X,Y) :- parent(P,X), parent(P,Y).
.output sibling";
> val it = "Compilation error: not found [x_20]" : string

(*) Negation - set difference
Datalog.execute ".decl student(name:string)
.decl graduate(name:string)
.decl undergraduate(name:string)
student(\"Alice\").
student(\"Bob\").
graduate(\"Alice\").
undergraduate(X) :- student(X), !graduate(X).
.output undergraduate";
> val it = {undergraduate=["Bob"]} : {undergraduate:string bag} variant

(*) Complex example - ancestor queries
Datalog.execute ".decl parent(p:string, c:string)
.decl ancestor(a:string, d:string)
.decl descendant(p:string, d:string)
parent(\"Alice\", \"Bob\").
parent(\"Bob\", \"Carol\").
parent(\"Carol\", \"Dan\").
ancestor(P,C) :- parent(P,C).
ancestor(A,D) :- ancestor(A,X), parent(X,D).
descendant(P,D) :- ancestor(D,P).
.output ancestor
.output descendant";
> val it =
>   {
>    ancestor=
>    [{a="Alice",d="Bob"},{a="Bob",d="Carol"},{a="Carol",d="Dan"},
>     {a="Alice",d="Carol"},{a="Bob",d="Dan"},{a="Alice",d="Dan"}],
>    descendant=
>    [{d="Alice",p="Bob"},{d="Bob",p="Carol"},{d="Carol",p="Dan"},
>     {d="Alice",p="Carol"},{d="Bob",p="Dan"},{d="Alice",p="Dan"}]}
>   : {ancestor:{a:string, d:string} bag, descendant:{d:string, p:string} bag} variant

(*) Empty relation
Datalog.validate ".decl empty(x:number)
.output empty";
> val it = "{empty:'a list}" : string

(*) Comments in Datalog
Datalog.execute "// Line comment
.decl edge(x:number, y:number)
/* Block comment */
edge(1,2).
.output edge";
> val it = {edge=[{x=1,y=2}]} : {edge:{x:int, y:int} bag} variant

(*) Execution - basic facts
Datalog.execute ".decl num(n:number)
num(1).
num(2).
num(3).
.output num";
> val it = {num=[1,2,3]} : {num:int bag} variant

(*) Execution - transitive closure
Datalog.execute ".decl edge(x:number, y:number)
.decl path(x:number, y:number)
edge(1,2).
edge(2,3).
path(X,Y) :- edge(X,Y).
path(X,Z) :- path(X,Y), edge(Y,Z).
.output path";
> val it = {path=[{x=1,y=2},{x=2,y=3},{x=1,y=3}]}
>   : {path:{x:int, y:int} bag} variant

(*
Translated:

fun edge(x, y) = (x, y) elem [(1, 2), (2, 3)];
fun path(x, z) = edge(x, z)
 orelse (exists y where path(x, y) andalso edge(y, z));
from x, z where path(x, z);

Expanded:

fun edge(x, y) = (x, y) elem [(1, 2), (2, 3)];
> val edge = fn : int * int -> bool
fun path(x, z) = edge(x, z) orelse
  (exists y in [1,2,3] where path(x, y) andalso edge(y, z));
> val path = fn : int * int -> bool
from x in [1,2,3], z in [1,2,3] where path(x, z);

*)

(*) Comparison operators - less than
Datalog.execute ".decl num(n:number)
.decl small(n:number)
num(1).
num(5).
num(10).
small(X) :- num(X), X < 7.
.output small";
> val it = {small=[1,5]} : {small:int bag} variant

(*) Comparison operators - greater than or equal
Datalog.execute ".decl num(n:number)
.decl large(n:number)
num(1).
num(5).
num(10).
large(X) :- num(X), X >= 5.
.output large";
> val it = {large=[5,10]} : {large:int bag} variant

(*) Comparison operators - not equal
Datalog.execute ".decl num(n:number)
.decl not_five(n:number)
num(1).
num(5).
num(10).
not_five(X) :- num(X), X != 5.
.output not_five";
> val it = {not_five=[1,10]} : {not_five:int bag} variant

(*) Comparison operators - equal
Datalog.execute ".decl edge(x:number, y:number)
.decl self_loop(x:number)
edge(1, 1).
edge(2, 3).
edge(4, 4).
self_loop(X) :- edge(X, Y), X = Y.
.output self_loop";
> val it = {self_loop=[1,4]} : {self_loop:int bag} variant

(*) End datalog.smli
