/*
 * Licensed to Julian Hyde under one or more contributor license
 * agreements.  See the NOTICE file distributed with this work
 * for additional information regarding copyright ownership.
 * Julian Hyde licenses this file to you under the Apache
 * License, Version 2.0 (the "License"); you may not use this
 * file except in compliance with the License.  You may obtain a
 * copy of the License at
 *
 * http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND,
 * either express or implied.  See the License for the specific
 * language governing permissions and limitations under the
 * License.
 */
package net.hydromatic.morel.compile;

import static java.util.Objects.requireNonNull;

import com.google.common.collect.ImmutableMap;
import com.google.common.collect.ImmutableSet;
import java.util.HashMap;
import java.util.Map;
import java.util.Optional;
import java.util.Set;
import net.hydromatic.morel.ast.Core;

/**
 * Registry for function invertibility analysis results.
 *
 * <p>Functions are analyzed ONCE at compile time and their invertibility status
 * is cached. This avoids the "mixing domains" problem where function bodies are
 * inlined onto the active inversion stack.
 *
 * <p>Per Scott Meyer's principle: "Edge should never be on the stack." Instead
 * of inlining function bodies during inversion, we look up the pre-computed
 * invertibility status and generator.
 */
public class FunctionRegistry {

  /**
   * Invertibility status of a function.
   *
   * <p>Determines how the function should be handled during predicate
   * inversion.
   */
  public enum InvertibilityStatus {
    /**
     * Function can be inverted to produce a finite generator.
     *
     * <p>Example: {@code fun edge(x,y) = (x,y) elem edges} inverts to generator
     * {@code edges}.
     */
    INVERTIBLE,

    /**
     * Function is recursive and requires Relational.iterate.
     *
     * <p>Example: {@code fun path(x,y) = edge(x,y) orelse (exists z where
     * edge(x,z) andalso path(z,y))}
     */
    RECURSIVE,

    /**
     * Function cannot be inverted; must use filter-based approach.
     *
     * <p>Example: {@code fun expensive(x) = complexComputation(x) > 100}
     */
    NOT_INVERTIBLE,

    /**
     * Function is partially invertible - some arguments can be generated, but
     * additional filtering is required.
     *
     * <p>Example: {@code fun f(x,y) = x > 5 andalso (x,y) elem pairs} can
     * generate from {@code pairs} but needs filter {@code x > 5}.
     */
    PARTIALLY_INVERTIBLE
  }

  /** Information about a function's invertibility. */
  public static final class FunctionInfo {
    private final InvertibilityStatus status;
    private final Core.Pat formalParameter;
    private final Optional<Core.Exp> baseGenerator;
    private final ImmutableSet<Core.NamedPat> canGenerateAlone;
    private final ImmutableSet<Core.Exp> requiredFilters;
    private final Optional<Core.Exp> recursiveStep;

    /**
     * Creates a FunctionInfo.
     *
     * @param status the invertibility status
     * @param formalParameter the function's formal parameter pattern
     * @param baseGenerator for INVERTIBLE functions, the generator expression;
     *     for RECURSIVE functions, the base case generator
     * @param canGenerateAlone set of variables that can be generated by this
     *     function alone (without additional context)
     * @param requiredFilters for PARTIALLY_INVERTIBLE, filters that must be
     *     applied after generation
     * @param recursiveStep for RECURSIVE functions, the step function for
     *     Relational.iterate
     */
    public FunctionInfo(
        InvertibilityStatus status,
        Core.Pat formalParameter,
        Optional<Core.Exp> baseGenerator,
        ImmutableSet<Core.NamedPat> canGenerateAlone,
        ImmutableSet<Core.Exp> requiredFilters,
        Optional<Core.Exp> recursiveStep) {
      this.status = requireNonNull(status, "status");
      this.formalParameter = requireNonNull(formalParameter, "formalParameter");
      this.baseGenerator = requireNonNull(baseGenerator, "baseGenerator");
      this.canGenerateAlone =
          requireNonNull(canGenerateAlone, "canGenerateAlone");
      this.requiredFilters = requireNonNull(requiredFilters, "requiredFilters");
      this.recursiveStep = requireNonNull(recursiveStep, "recursiveStep");
    }

    public InvertibilityStatus status() {
      return status;
    }

    public Core.Pat formalParameter() {
      return formalParameter;
    }

    public Optional<Core.Exp> baseGenerator() {
      return baseGenerator;
    }

    public ImmutableSet<Core.NamedPat> canGenerateAlone() {
      return canGenerateAlone;
    }

    public ImmutableSet<Core.Exp> requiredFilters() {
      return requiredFilters;
    }

    public Optional<Core.Exp> recursiveStep() {
      return recursiveStep;
    }

    /** Creates info for an invertible function with a simple generator. */
    public static FunctionInfo invertible(
        Core.Pat formalParameter,
        Core.Exp generator,
        Set<Core.NamedPat> canGenerateAlone) {
      return new FunctionInfo(
          InvertibilityStatus.INVERTIBLE,
          formalParameter,
          Optional.of(generator),
          ImmutableSet.copyOf(canGenerateAlone),
          ImmutableSet.of(),
          Optional.empty());
    }

    /** Creates info for a recursive function. */
    public static FunctionInfo recursive(
        Core.Pat formalParameter,
        Core.Exp baseGenerator,
        Core.Exp recursiveStep,
        Set<Core.NamedPat> canGenerateAlone) {
      return new FunctionInfo(
          InvertibilityStatus.RECURSIVE,
          formalParameter,
          Optional.of(baseGenerator),
          ImmutableSet.copyOf(canGenerateAlone),
          ImmutableSet.of(),
          Optional.of(recursiveStep));
    }

    /** Creates info for a non-invertible function. */
    public static FunctionInfo notInvertible(Core.Pat formalParameter) {
      return new FunctionInfo(
          InvertibilityStatus.NOT_INVERTIBLE,
          formalParameter,
          Optional.empty(),
          ImmutableSet.of(),
          ImmutableSet.of(),
          Optional.empty());
    }

    /** Creates info for a partially invertible function. */
    public static FunctionInfo partiallyInvertible(
        Core.Pat formalParameter,
        Core.Exp generator,
        Set<Core.NamedPat> canGenerateAlone,
        Set<Core.Exp> requiredFilters) {
      return new FunctionInfo(
          InvertibilityStatus.PARTIALLY_INVERTIBLE,
          formalParameter,
          Optional.of(generator),
          ImmutableSet.copyOf(canGenerateAlone),
          ImmutableSet.copyOf(requiredFilters),
          Optional.empty());
    }
  }

  /** Mutable builder for constructing a FunctionRegistry. */
  private final Map<Core.NamedPat, FunctionInfo> registry = new HashMap<>();

  /** Creates an empty function registry. */
  public FunctionRegistry() {}

  /**
   * Registers a function's invertibility information.
   *
   * @param fnPat the function's name pattern
   * @param info the invertibility information
   */
  public void register(Core.NamedPat fnPat, FunctionInfo info) {
    registry.put(requireNonNull(fnPat, "fnPat"), requireNonNull(info, "info"));
  }

  /**
   * Looks up a function's invertibility information.
   *
   * @param fnPat the function's name pattern
   * @return the function info, or empty if not registered
   */
  public Optional<FunctionInfo> lookup(Core.NamedPat fnPat) {
    return Optional.ofNullable(registry.get(fnPat));
  }

  /**
   * Returns whether a function is registered.
   *
   * @param fnPat the function's name pattern
   * @return true if the function has been analyzed and registered
   */
  public boolean isRegistered(Core.NamedPat fnPat) {
    return registry.containsKey(fnPat);
  }

  /**
   * Returns an immutable snapshot of all registered functions.
   *
   * @return map from function pattern to info
   */
  public ImmutableMap<Core.NamedPat, FunctionInfo> snapshot() {
    return ImmutableMap.copyOf(registry);
  }

  /**
   * Returns the number of registered functions.
   *
   * @return count of registered functions
   */
  public int size() {
    return registry.size();
  }

  @Override
  public String toString() {
    return "FunctionRegistry(" + registry.size() + " functions)";
  }
}
// End FunctionRegistry.java
